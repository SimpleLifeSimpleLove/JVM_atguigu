# 第8章 堆

* 整个系列学习路线

<img src="images/120.png" alt="img" style="zoom:67%;" />

## 1 堆的核心概述

<img src="images/121.png" alt="img" style="zoom:67%;" />

* 每个进程对应一个JVM实例，对应一个Runtime；一个进程对应多个线程，一个线程对应一个程序计数器、虚拟机栈、本地方法栈。一个进程中的线程要共享堆空间和方法区

* 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域，演示如下：

  ```java
  /**
   * -Xms10m -Xmx10m
   */
  public class HeapDemo {
      public static void main(String[] args) {
          System.out.println("start...");
          try {
              Thread.sleep(1000000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println("end...");
      }
  }
  ```

  ```java
  /**
   * -Xms20m -Xmx20m
   */
  public class HeapDemo1 {
      public static void main(String[] args) {
          System.out.println("start...");
          try {
              Thread.sleep(1000000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println("end...");
      }
  }
  ```

  运行程序后，使用jdk8自带的jvisualvm.exe查看程序的详细信息

  <img src="images/122.png" alt="img" style="zoom:95%;" />

  <img src="images/123.png" alt="img" style="zoom:90%;" />

  <img src="images/124.png" alt="img" style="zoom:95%;" />

  <img src="images/125.png" alt="img" style="zoom:95%;" />

* Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间

  * 堆内存的大小是可以调节的

* 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存够空间中，但是逻辑上它应该被视为连续的。

* 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB），这样可以提高并发性

---

* 《Java虚拟机规范》中对Java堆的描述是：<font color=red>**所有的对象实例以及数组**</font>都应当在运行时分配到堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）

  * 我要说的是：“几乎”所有的对象实例都是在堆上分配内存。------从实际使用角度看的。

* 数组和对象可能永远不会存储在沾上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。

* 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收的时候才会被移除。

* 堆，是GC（Garbage Collection）执行垃圾回收的重点区域

* 代码演示

  ```java
  public class SimpleHeap {
      private int id;  // 属性、成员变量
  
      public SimpleHeap(int id) {
          this.id = id;
      }
  
      public void show() {
          System.out.println("My ID is " + id);
      }
  
      public static void main(String[] args) {
          SimpleHeap sl = new SimpleHeap(1);
          SimpleHeap s2 = new SimpleHeap(2);
  
          int[] arr = new int[10];
          Object[] arr1 = new Object[10];
      }
  }
  ```

  <img src="images/126.png" alt="img" style="zoom:67%;" />

  <img src="images/127.png" alt="img" style="zoom:77%;" />

---

* 内存细分

  <img src="images/128.png" alt="img" style="zoom:67%;" />

  * 堆空间内部结构（JDK7）

    <img src="images/129.png" alt="img" style="zoom:67%;" />

    <img src="images/131.png" alt="img" style="zoom:87%;" />

  * 堆空间内部结构（JDK8）

    <img src="images/130.png" alt="img" style="zoom:67%;" />

    对于前面的SimpleHeap，设置参数：-Xms10m -Xmx10m -XX:+PrintGCDetails	运行后的结果如下：

    <img src="images/132.png" alt="img" style="zoom:87%;" />

## 2 设置堆内存大小与OOM

* 堆空间大小的设置

  * Java堆空间用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项“-Xms”和"-Xmx"来进行设置。

    * “-Xms”用于标识堆区的起始内存，等价于-XX:InitialHeapSize
    * “-Xmx”则用于标识堆区的最大内存，等价于-XX:MaxHeapSize

  * 一旦堆区的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError异常。

  * 通常会将“-Xms”和“-Xmx”两个参数设置成相同的值，其<font color=red>**目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能**</font>。

  * 默认情况下，初始内存大小：物理电脑内存大小 / 64

    ​						最大内存大小：物理电脑内存大小 / 4

  ```java
  /**
   * 1. 设置堆空间大小的参数
   * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小
   *      -X 是jvm的运行参数
   *      ms 是memory start
   * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小
   *
   * 2. 默认堆空间的大小
   *    初始内存大小：物理电脑内存大小 / 64
   *             最大内存大小：物理电脑内存大小 / 4
   * 3. 手动设置：-Xms600m -Xmx600m
   *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。原因是扩容缩容会造成服务器不必要的压力
   *
   * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id
   *                  方式二：-XX:+PrintGCDetails
   */
  public class HeapSpaceInitial {
      public static void main(String[] args) {
  
          // 返回Java虚拟机中的堆内存总量
          long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;
          // 返回Java虚拟机试图使用的最大堆内存量
          long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;
  
          System.out.println("-Xms : " + initialMemory + "M");
          System.out.println("-Xmx : " + maxMemory + "M");
  
          System.out.println("系统内存大小为：" + initialMemory * 64.0 / 1024 + "G");
          System.out.println("系统内存大小为：" + maxMemory * 4.0 / 1024 + "G");
  
          try {
              Thread.sleep(1000000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      }
  }
  ```

  **如果没有设置任何参数，则结果：**

  ​			-Xms : 245M

  ​			-Xmx : 3614M

  ​			系统内存大小为：15.3125G

  ​			系统内存大小为：14.1171875G

  **如果设置参数-Xms600m -Xmx600m，此时值关注前两项结果：**

  ​			-Xms : 575M

  ​			-Xmx : 575M

  <img src="images/133.png" alt="img" style="zoom:90%;" />

  不是600M，因为幸存者区有两个，但是只计算了一个

  (25600+25600+153600+409600) / 1024 = 600M

  (25600+153600+409600) / 1024 = 575M

  <img src="images/134.png" alt="img" style="zoom:90%;" />

* OOM：OutOfMemoeyError

  <img src="images/135.png" alt="img" style="zoom:80%;" />

  * 代码演示

  ```java
  public class OOMTest {
      public static void main(String[] args) {
          ArrayList<Picture> list = new ArrayList<>();
          while (true) {
              try {
                  Thread.sleep(20);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              list.add(new Picture(new Random().nextInt(1024 * 1024)));
          }
      }
  }
  
  class Picture {
      private byte[] pixels;
  
      public Picture(int length) {
          this.pixels = new byte[length];
      }
  }
  ```

  **结果：**

  <img src="images/136.png" alt="img" style="zoom:80%;" />

  <img src="images/137.png" alt="img" style="zoom:80%;" />

## 3 年轻代与老年代

* 存储在JVM中的Java对象可以被划分为两类：
  * 一类是声明周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
  * 另一类对象的声明周期非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。
* Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）
* 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区，谁空谁为to区）

<img src="images/138.png" alt="img" style="zoom:77%;" />

---

* 下面的参数开发中一般不会调：

  <img src="images/139.png" alt="img" style="zoom:77%;" />

* 配置新生代和老年代在堆结构的占比

  * 默认**-XX:NewRatio=2**，表示新生代占1，老年代占2，新生代占整个堆的1/3

  * 可以修改**-XX:NewRatio=4**，表示新生代占1，老年代占4，新生代占整个堆的1/5

  * 代码演示

    ```java
    /**
     * -Xms600m -Xmx600m
     *
     * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2.
     * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8
     * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）
     * -Xmn:设置新生代的空间的大小。 （一般不设置）
     */
    public class EdenSurvivorTest {
        public static void main(String[] args) {
            System.out.println("我只是来打个酱油~");
            try {
                Thread.sleep(1000000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    ```

    <img src="images/140.png" alt="img" style="zoom:97%;" />

---

* 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1

  * 但实际上比例是6:1:1，即使关闭自适应机制（-XX:-UseAdaptiveSizePolicy）也是6:1:1，即使通过命令（jinfo -flag NewRatio）查看看到的数值是8

    <img src="images/141.png" alt="img" style="zoom:95%;" />

    <img src="images/142.png" alt="img" style="zoom:95%;" />

    想要变成8:1:1可以通过设置“-XX:SurvivorRatio=8”实现

* 当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8

* <font color=red>**几乎所有的**</font>Java对象都是在Eden去被new出来的。

  * 如果对象太大，Eden放不下，需要直接放到老年区，仍然放不下的话，会报错。

* 绝大部分Java对象的销毁都在新生代进行了。

  * IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。

* 可以使用选项“-Xmn”设置新生代最大内存大小

  * 这个参数一般使用默认值就可以了。
  * 如果这个参数和"-XX:NewRatio"产生矛盾，以“-Xmn”为准

<img src="images/143.png" alt="img" style="zoom:67%;" />

## 4 图解对象分配过程

* 概述：为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。

  1. new的对象首先放到伊甸园区。此区有大小限制。

  2. 当伊甸园区的空间填满时，程序又需创建对象，JVM的垃圾回收器会对伊甸园区进行垃圾回收（Minor GC / Young GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象到伊甸园区

  3. 然后将伊甸园区中的剩余对象移动到幸存者0区。

  4. 如果再次出发垃圾回收，此时上次幸存下来的放到幸存者0区，如果没有回收，就会放到幸存者1区。

  5. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。

  6. 啥时候能去养老区呢？可以设置次数。默认是15次。

     * <font color=red>**可以设置参数：-XX:MaxTenuringThreshold=<N>进行设置**</font>。

       <img src="images/144.png" alt="img" style="zoom:95%;" />

  7. 在养老区，相对悠闲。当养老区内存不足时，再次出发：Major GC，进行养老区的内存清理。

  8. 若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常

     * <font color=red>**java.lang.OutOfMemoryError: Java heap space**</font>

<img src="images/145.png" alt="img" style="zoom:67%;" />

* 注意点：当幸存者区满的时候不会出发Young GG；但是当伊甸园区满的时候，会出发Young GC，同时也会对幸存者区进行GC；幸存者区被动GC
* 总结：
  * <font color=red>**针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to**</font>。
  * <font color=red>**关于垃圾回收：频繁收集新生代，较少收集老年代，几乎不动永久区/元空间**</font>。

* 对象分配详细过程

<img src="images/146.png" alt="img" style="zoom:67%;" />

74

## 5 Minor GC、Major GC、Full GC



## 6 堆空间分带思想



## 7 内存分配策略



## 8 为对象分配内存：TLAB



## 9 小结堆空间的参数设置



## 10 堆是分配对象的唯一选择吗？