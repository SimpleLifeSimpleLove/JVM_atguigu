# JVM系列1：内存与垃圾回收篇

## 第1章 JVM和Java体系结构

### 1 前言

* <font color=red>**你是否也遇到过这些问题？**</font>
  * 运行着的线上系统突然卡死，系统无法访问，甚至直接OOM！
  * 想解决线上JVM GC问题，却无从下手
  * 新项目上线，对各种JVM参数设置一脸茫然，直接默认吧，然后就JJ了
  * 每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优JVM参数，如何解决GC、OOM等问题，一脸懵逼。
* 大部分Java开发人员，除会在项目中使用到与Java平台相关的各种高精尖技术之外，对于Java技术的核心Java虚拟机了解甚少

<img src="images/1.png" alt="img" style="zoom:50%;" />

* 开发人员如何看待上层框架？

  * 一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。
  * 如果我们把核心类库的API比作数学公式的话，那么Java虚拟机的知识就好比公式的推导过程

* 计算机系统体系对我们来说越来越远，在不了解底层实现的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言

  <img src="images/2.png" alt="img" style="zoom:50%;" />

* <font color=red>**架构师每天都在思考什么？**</font>

  * 应该如何让我的系统更快？
  * 如何避免系统出现瓶颈？

* 知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？

  * 参与现有系统的性能优化，重构，保证平台性能和稳定性
  * 根据业务场景和需求，决定技术方向，做技术选型
  * 能够独立架构和设计海量数据下的并发分布式解决方案，满足功能和非功能需求
  * 解决各类潜在的系统风险，核心功能的架构与代码编写
  * 分析系统瓶颈，解决各种疑难杂症，性能调优等

* 我们为什么要学习JVM？

  * 面试的需要（BATJ、TMD、PKQ面试都爱问）
  * 中高级程序员必备技能
    * 项目管理、调优的需要
  * 追求极客的精神
    * 比如：垃圾回收算法、JIT、底层原理

* Java  vs  C++

  ![img](images/3.png)

### 2 面向人群及参考书目

* 面向人群

  * 拥有一定开发经验的Java平台开发人员
  * 软件设计师、架构师
  * 系统调优人员
  * 有一定的Java编程基础并希望进一步了解Java的程序员
  * 虚拟机爱好者，JVM实践者

* 这个课怎么讲？

  * 理论时间 多于 代码时间
  * 通俗、易懂、讲人话
  * 图解

* 参考书目

  java8规范网址：https://docs.oracle.com/javase/specs/jls/se8/html/index.html

  ![img](images/4.png)

  ![img](images/5.png)

  ![img](images/6.png)

  ![img](images/7.png)

### 3 Java及JVM简介

* 语言热度排行榜：https://www.tiobe.com/tiobe-index/

* Java生态圈

  * <font color=red>**作为一个平台**</font>：Java虚拟机扮演着举足轻重的作用。Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分
  * <font color=red>**作为一种文化**</font>：
    * 第三方开源软件和框架。如Tomcat、Struts、MyBatis、Spring等。
    * 就连JDK和JVM自身也有不少开源的实现，如OpenJDK、Harmony。
  * <font color=red>**作为一个社区**</font>：Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。

* Java：跨平台的语言

  <img src="images/8.png" alt="img" style="zoom:50%;" />

* Java虚拟机规范

  ![img](images/9.png)

* JVM：跨语言的平台

  ![img](images/10.png)

  * 随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在<font color=red>**Java虚拟机平台运行非Java语言编写的程序**</font>
  * Java虚拟机根本不关心运行在其内部的程序到底是使用何种语言编写的，<font color=red>**它值关心“字节码”文件**</font>。

* <font color=red>**Java不是最强大的语言，但是JVM是最强大的虚拟机。**</font>

* 我们平时说的java字节码，指的是用java语言编写成的字节码。准确的说任何能在jvm平台执行的字节码格式都是一样的。所以应该统称为：<font color=red>**jvm字节码**</font>。

* 不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。

* Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式------Class文件格式所关联，Class文件包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。

* 多语言混合编程

  * <font color=red>**Java平台上的多语言混合编程称为主流，通过特定的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向**</font>。
  * 试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层使用Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，<font color=red>**各种语言之间的交互不存在任何困难，就像使用自己语言的原生PAI一样方便，因为它们最终都运行在一个虚拟机上**</font>。
  * 对这些运行在Java虚拟机上、Java之外的语言，来自系统的、底层的支持正在迅速增长，以JSR-292为核心的一系列项目和功能改进（如DaCinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），<font color=red>**推动Java虚拟机从“Java语言的虚拟机”向“多语言虚拟机”的方向发展**</font>。

* 如何真正搞懂JVM？

  <img src="images/11.png" alt="img" style="zoom:60%;" />

### 4 Java发展的重大事件

![img](images/12.png)

![img](images/13.png)

![img](images/14.png)

### 5 虚拟机与Java虚拟机

* 虚拟机

  * 所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<font color=red>**系统虚拟机**</font>和<font color=red>**程序虚拟机**</font>。
    * 大名鼎鼎的Vitural Box，VMware就属于系统虚拟机，他们<font color=red>**完全是对物理计算机的仿真**</font>，提供了一个可运行完整操作系统的软件平台
    * 程序虚拟机的典型代表就是Java虚拟机，它<font color=red>**专门为执行单个计算机程序而设计**</font>，在Java虚拟机中执行的命令我们称为Java字节码指令。
  * 无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中

* Java虚拟机

  * Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必是由Java语言编写而成的。
  * JVM平台的各种语言可以共享Java虚拟机的跨平台、优秀的垃圾回收器，以及可靠的及时编译器。
  * <font color=red>**Java技术的核心就是Java虚拟机**</font>（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部
  * 作用：<font color=red>**Java虚拟机就是二进制字节码的运行环境**</font>，负责装在字节码到其内部，解释/编译为对应平台的机器指令执行。每一条Java命令，Java虚拟机规范都有详细定义，如怎么去操作数，处理结果放在哪里。
  * 特点
    * 一次编译，导出运行
    * 自动内存管理
    * 自动垃圾回收功能

* JVM的位置

  <img src="images/15.png" alt="img" style="zoom:50%;" />

  <img src="images/16.png" alt="img" style="zoom:70%;" />

* Google的Android系统结构

  ![img](images/17.png)

  Dalvik Virtal Machine解释执行.dex文件

### 6 JVM整体结构

<img src="images/18.png" alt="img" style="zoom:70%;" />

<img src="images/19.png" alt="img" style="zoom:70%;" />

### 7 Java代码执行流程

<img src="images/8.png" alt="img" style="zoom:50%;" />

<img src="images/20.png" alt="img" style="zoom:75%;" />

### 8 JVM的架构模型

* Java编译器输入的指令流基本上是一种基于<font color=red>**栈的指令集架构**</font>，另外一种指令集架构则是基于<font color=red>**寄存器的指令集架构**</font>。

* 具体来说：这两种架构之间的区别：

  * <font color=red>**基于栈式架构的特点**</font>：
    * 设计和实现简单，适用于资源受限的系统；
    * 避开了寄存器的分配难题：使用零地址指令方式分配。
    * 指令流中的大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。
    * 不需要硬件支持，可移植性更好，更好实现跨平台
  * <font color=red>**基于寄存器架构的特点**</font>
    * 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。
    * 指令集架构则完全依赖硬件，可移植性差
    * 性能优秀和执行高效；
    * 花费更少的指令去完成一项操作。
    * 在大部分情况下，基于寄存器架构的指令集往往都是以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。

* 举例：反编译javap

  ```java
  public class StackStruTest {
      public static void main(String[] args) {
          //int i = 2 + 3;
          int i = 2;
          int j = 3;
          int k = i + j;
      }
  }
  ```

  <img src="images/21.png" alt="img" style="zoom:75%;" />

  <img src="images/22.png" alt="img" style="zoom:60%;" />

  <img src="images/23.png" alt="img" style="zoom:60%;" />

  <img src="images/24.png" alt="img" style="zoom:60%;" />

  <img src="images/25.png" alt="img" style="zoom:70%;" />

  <img src="images/26.png" alt="img" style="zoom:70%;" />

* 总结：
  * <font color=red>**由于跨平台的设计，Java的指令都是根据栈来设计的**</font>。不同平台的CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。
  * 时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？这是因为这种方式实现简单；另外基于栈式的结果在各个平台可以用，没必要更换了。

### 9 JVM的生命周期

* **虚拟机的启动**

  * Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。

* **虚拟机的执行**

  * 一个运行的Java虚拟机有着一个清晰的任务：执行Java程序。
  * 程序开始执行时他才运行，程序结束时他就停止。
  * <font color=red>**执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程**</font>。

* **虚拟机的退出**

  * 有如下的几种情况：

    * 程序正常执行结束
    * 程序在执行过程中遇到了异常或错误而异常终止
    * 由于操作系统出现错误而导致Java虚拟机进程结束
    * 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。
    * 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载Java虚拟机是，Java虚拟机的退出情况。

  * System

    ```java
    public final class System {
        // ...
        
        public static void exit(int status) {
            Runtime.getRuntime().exit(status);
        }
        
        // ...
    }
    ```

  * Runtime

    ```java
    public class Runtime {
        private static Runtime currentRuntime = new Runtime();
    
        public static Runtime getRuntime() {
            return currentRuntime;
        }
    
        /** Don't let anyone else instantiate this class */
        private Runtime() {}
        
        // ...
        
        public void exit(int status) {
            SecurityManager security = System.getSecurityManager();
            if (security != null) {
                security.checkExit(status);
            }
            Shutdown.exit(status);
        }
        
        // ...
        
        public void halt(int status) {
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                sm.checkExit(status);
            }
            Shutdown.halt(status);
        }
        
        // ...
    }
    ```

    一个进程对应一个JVM，一个JVM就对应着一个Runtime

### 10 JVM的发展历程

<img src="images/27.png" alt="img" style="zoom:50%;" />

<img src="images/28.png" alt="img" style="zoom:50%;" />

<img src="images/29.png" alt="img" style="zoom:50%;" />

<img src="images/30.png" alt="img" style="zoom:50%;" />

<img src="images/31.png" alt="img" style="zoom:50%;" />

<img src="images/32.png" alt="img" style="zoom:50%;" />

<img src="images/33.png" alt="img" style="zoom:50%;" />

<img src="images/34.png" alt="img" style="zoom:50%;" />

<img src="images/35.png" alt="img" style="zoom:50%;" />

<img src="images/36.png" alt="img" style="zoom:50%;" />

<img src="images/37.png" alt="img" style="zoom:50%;" />

<img src="images/38.png" alt="img" style="zoom:50%;" />

将.apk文件改为.zip格式的，然后解压，里面显示的内容如下，我们可以看到.dex文件

<img src="images/39.png" alt="img" style="zoom:60%;" />

<img src="images/40.png" alt="img" style="zoom:60%;" />

<img src="images/41.png" alt="img" style="zoom:50%;" />

* 具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一昌盛发布的不同版本，都有可能存在一定差异。本套课程主要以Oracle HotSpot VM为默认虚拟机。

<img src="images/42.png" alt="img" style="zoom:50%;" />

* 如何知道学习什么技术？
  * 关注大公司用什么技术，比如阿里在大数据方面已经全面倒向Flink了，我们就应该学习Flink

## 第2章 类加载子系统

### 1 内存结构概述

* 简图

<img src="images/43.png" alt="img" style="zoom:70%;" />

* 详细图（英文版）

<img src="images/19.png" alt="img" style="zoom:70%;" />

* 详细图（中文版）

<img src="images/44.png" alt="img" style="zoom:70%;" />

* 类加载器子系统

<img src="images/45.png" alt="img" style="zoom:70%;" />

* 运行时数据区

<img src="images/46.png" alt="img" style="zoom:70%;" />

* 执行引擎等

<img src="images/47.png" alt="img" style="zoom:70%;" />

* 如果自己手写一个Java虚拟机的话，主要考虑哪些结构呢？
  * 类加载器和执行引擎

### 2 类加载器与类的加载过程

* 类加载器子系统作用

  * 类加载器子系统作用负责从文件系统或者网络中加载Class文件，class文件在文件开头会有特定的文件标识。
  * ClassLoader只负责class文件的加载，只与它是否可以运行，则由Execution Engine决定。
  * 加载的类信息存放在一块称为<font color=red>**方法区**</font>的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息时Class文件中常量池部分的内存映射）

* 类加载器ClassLoader的角色

  <img src="images/48.png" alt="img" style="zoom:60%;" />

* 类的加载过程

  <img src="images/49.png" alt="img" style="zoom:70%;" />

  ```java
  public class HelloLoader {
      public static void main(String[] args) {
          System.out.println("谢谢ClassLoader加载我....");
          System.out.println("你的大恩大德，我下辈子再报！");
      }
  }
  ```

  <img src="images/50.png" alt="img" style="zoom:70%;" />

  * 加载：

    1. 通过一个类的全限名获取定义此类的二进制字节流

    2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
    3. <font color=red>**在内存中生成一个代表这个类的java.lang.Class对象**</font>，作为方法区这个类的各种数据的访问入口

    * 补充：加载.class文件放入方式
      * 从本地系统中直接加载
      * 通过网络获取，典型场景：Web Applet
      * 从zip压缩包中读取，成为日后jar、war格式的基础
      * 运行时计算生成，使用最多的是：动态代理技术
      * 由其他文件生成，典型场景：JSP应用
      * 从专有数据库中提取.class文件，比较少见
      * 从加密文件中获取，典型的防Class文件被反编译的保护措施

  * 链接

    ![img](images/51.png)

  * 初始化

    ![img](images/52.png)

    ---

    ```java
    public class ClassInitTest {
       private static int num = 1;
    
       static{
           num = 2;
           number = 20;
           System.out.println(num);
           //System.out.println(number);//报错：非法的前向引用。
       }
    
       private static int number = 10;  // linking之prepare: number = 0 --> initial: 20 --> 10
    
        public static void main(String[] args) {
            System.out.println(ClassInitTest.num);  // 2
            System.out.println(ClassInitTest.number);  // 10
        }
    }
    ```

    **结果：**

    ​			2

    ​			10

    通过jclasslib可以查看其内部执行过程

    ![img](images/53.png)

    ---

    JVM会保证父类的\<clinit>()首先执行

    ```java
    public class ClinitTest1 {
        static class Father{
            public static int A = 1;
            static{ A = 2; }
        }
    
        static class Son extends Father{
            public static int B = A;
        }
    
        public static void main(String[] args) {
            //加载Father类，其次加载Son类。
            System.out.println(Son.B);//2
        }
    }
    ```

    ---

    虚拟机必须保证一个类的\<clinit>()方法在多线程下被同步加锁，并且只会被加载一次

    ```java
    public class DeadThreadTest {
        public static void main(String[] args) {
            Runnable r = () -> {
                System.out.println(Thread.currentThread().getName() + "开始");
                DeadThread dead = new DeadThread();
                System.out.println(Thread.currentThread().getName() + "结束");
            };
    
            Thread t1 = new Thread(r,"线程1");
            Thread t2 = new Thread(r,"线程2");
    
            t1.start();
            t2.start();
        }
    }
    
    class DeadThread{
        static{
            if(true){
                System.out.println(Thread.currentThread().getName() + "初始化当前类");
                while(true){
    
                }
            }
        }
    }
    ```

    **结果：**

    ​			线程1开始

    ​			线程2开始

    ​			线程1初始化当前类

    ​			线程2结束

    ​			线程1结束

### 3 类加载器分类

* JVM支持两种类型的类加载器，分别是<font color=red>**引导类加载器（Bootstrap ClassLoader）**</font>和<font color=red>**自定义类加载器（User-Defined ClassLoader）**</font>

* 从概念上讲，自定义类加载器是指程序中由开发人员自定义的一类加载器，然而Java虚拟机规范却并没有这么定义，而是<font color=red>**将所有派生与抽象类ClassLoader的类加载器都划分为自定义类加载器**</font>。

* 无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有三个，如下图：

  <img src="images/54.png" alt="img" style="zoom:55%;" />

  Bootstrap ClassLoader是由C++语言实现的，其余的是由Java语言实现的

  <img src="images/55.png" alt="img" style="zoom:65%;" />

  ---

  ```java
  public class ClassLoaderTest {
      public static void main(String[] args) {
  
          //获取系统类加载器
          ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
          System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2
  
          //获取其上层：扩展类加载器
          ClassLoader extClassLoader = systemClassLoader.getParent();
          System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@1540e19d
  
          //获取其上层：获取不到引导类加载器
          ClassLoader bootstrapClassLoader = extClassLoader.getParent();
          System.out.println(bootstrapClassLoader);//null
  
          //对于用户自定义类来说：默认使用系统类加载器进行加载
          ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
          System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2
  
          //String类使用引导类加载器进行加载的。---> Java的核心类库都是使用引导类加载器进行加载的。
          ClassLoader classLoader1 = String.class.getClassLoader();
          System.out.println(classLoader1);//null
      }
  }
  ```

* 虚拟机自带的加载器

  * 启动类加载器（引导类加载器，Bootstrap ClassLoader）
    * 这个类加载使用<font color=red>**C/C++语言实现的**</font>，嵌套在JVM内部
    * 它用来加载Java核心类库(JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容)，用于提供JVM自身需要的类
    * 并不继承自java.lang.ClassLoader，没有父加载器
    * 加载扩展类和应用程序加载器，并指定为他们的父类加载器
    * 处于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类
  * 扩展类加载器（Extension ClassLoader）
    * <font color=red>**Java语言编写**</font>，由sun.misc.Launcher$ExtClassLoader实现。
    * <font color=red>**派生于ClassLoader类**</font>
    * 父类加载器为启动类加载器
    * 从java.ext.dirs系统属性所指定的目录加载类库，或从JDK安装目录的jre/lib/ext子目录（扩展目录）下加载类库。<font color=red>**如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载**</font>。
  * 应用程序类加载器（系统类加载器，AppClassLoader）
    * java语言编写，由sun.misc.Launcher$ExtClassLoader实现。
    * <font color=red>**派生于ClassLoader类**</font>
    * 父类加载器为启动类加载器
    * 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
    * <font color=red>**该类加载是程序中默认的类加载器**</font>，一般来说，Java应用的类都是由它来完成加载
    * 通过ClassLoader.getSystemClassLoader()方法可以获取到该类加载器

* 加载器加载内容

  ```java
  public class ClassLoaderTest1 {
      public static void main(String[] args) {
          System.out.println("------------启动类加载器------------");
          //获取BootstrapClassLoader能够加载的api的路径
          URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();
          for (URL element : urLs) {
              System.out.println(element.toExternalForm());
          }
          //从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器
          ClassLoader classLoader = Provider.class.getClassLoader();
          System.out.println(classLoader);
  
          System.out.println("------------扩展类加载器------------");
          String extDirs = System.getProperty("java.ext.dirs");
          for (String path : extDirs.split(";")) {
              System.out.println(path);
          }
          //从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器
          ClassLoader classLoader1 = CurveDB.class.getClassLoader();
          System.out.println(classLoader1);//sun.misc.Launcher$ExtClassLoader@1540e19d
      }
  }
  ```

  **结果：**

  ​			------------启动类加载器------------

  ​			file:/D:/Java/jdk1.8.0_231/jre/lib/resources.jar

  ​			file:/D:/Java/jdk1.8.0_231/jre/lib/rt.jar

  ​			file:/D:/Java/jdk1.8.0_231/jre/lib/sunrsasign.jar

  ​			file:/D:/Java/jdk1.8.0_231/jre/lib/jsse.jar

  ​			file:/D:/Java/jdk1.8.0_231/jre/lib/jce.jar

  ​			file:/D:/Java/jdk1.8.0_231/jre/lib/charsets.jar

  ​			file:/D:/Java/jdk1.8.0_231/jre/lib/jfr.jar

  ​			file:/D:/Java/jdk1.8.0_231/jre/classes

  ​			null

  ​			------------扩展类加载器------------

  ​			D:\Java\jdk1.8.0_231\jre\lib\ext

  ​			C:\WINDOWS\Sun\Java\lib\ext

  ​			sun.misc.Launcher$ExtClassLoader@12a3a380

* 用户自定义类加载器

  * 在Java日常应用程序开发中，类的加载几乎是由上述3种加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。
  * 为什么需要自定义类加载器？
    * 隔离加载类
    * 修改类加载的方式
    * 扩展加载源
    * 防止源码泄露
  * 用户自定义类加载器实现步骤：
    * 开发人员可以通过集成抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求
    * 在JDK1.2之前，在自定义类加载器时，总会去集成ClassLoader类并重写loadClass()方法，从而实现自定义的类加载器，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑卸载findClass()方法中
    * 在编写自定义的类加载器时，如果没有过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及获取字节码流的方式，使自定义类加载器编写更加简洁。

  ```java
  public class CustomClassLoader extends ClassLoader {
      @Override
      protected Class<?> findClass(String name) throws ClassNotFoundException {
  
          try {
              byte[] result = getClassFromCustomPath(name);
              if(result == null){
                  throw new FileNotFoundException();
              }else{
                  return defineClass(name,result,0,result.length);
              }
          } catch (FileNotFoundException e) {
              e.printStackTrace();
          }
  
          throw new ClassNotFoundException(name);
      }
  
      private byte[] getClassFromCustomPath(String name){
          //从自定义路径中加载指定类:细节略
          //如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。
          return null;
      }
  
      public static void main(String[] args) {
          CustomClassLoader customClassLoader = new CustomClassLoader();
          try {
              Class<?> clazz = Class.forName("One",true,customClassLoader);
              Object obj = clazz.newInstance();
              System.out.println(obj.getClass().getClassLoader());
          } catch (Exception e) {
              e.printStackTrace();
          }
      }
  }
  ```

### 4 ClassLoader的使用说明

* ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）

  ![img](images/56.png)

  <img src="images/55.png" alt="img" style="zoom:65%;" />

* 获取ClassLoader的途径

  * 方式一：获取当前类的ClassLoader：class.getClassLoader()
  * 方式二：获取当前线程上下文的ClassLoader：Thread.current().getContextLoader()
  * 方式三：获取系统的ClassLoader：ClassLoader.getSystemClassLoader()
  * 方式四：获取调用者的ClassLoader：DriverManager.getCallerClassLoader()

  ```java
  public class ClassLoaderTest2 {
      public static void main(String[] args) {
          try {
              //1.
              ClassLoader classLoader = Class.forName("java.lang.String").getClassLoader();
              System.out.println(classLoader);
              //2.
              ClassLoader classLoader1 = Thread.currentThread().getContextClassLoader();
              System.out.println(classLoader1);
              //3.
              ClassLoader classLoader2 = ClassLoader.getSystemClassLoader().getParent();
              System.out.println(classLoader2);
  
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          }
      }
  }
  ```

  **结果：**

  ​			null

  ​			sun.misc.Launcher$AppClassLoader@18b4aac2

  ​			sun.misc.Launcher$ExtClassLoader@1b6d3586

### 5 双亲委派机制

* Java虚拟机对class文件采用的是<font color=red>**按需加载**</font>的方式，也就是说当需要使用该类时才会将他的class文件加载到内存生成Class对象。而且加载某个类的class文件是=时，Java虚拟机采用的是<font color=red>**双亲委派机制**</font>，即把请求交由父类处理，它是一种任务委派模式。

* 一个问题？在当前模块下，创建一个java.lang.String类，并使用，会使用我们创建的String吗？

  <img src="images/57.png" alt="img" style="zoom:85%;" />

  ```java
  public class String {
      //
      static{
          System.out.println("我是自定义的String类的静态代码块");
      }
  //    //错误: 在类 java.lang.String 中找不到 main 方法
  //    public static void main(String[] args) {
  //        System.out.println("hello,String");
  //    }
  }
  ```

  ```java
  public class StringTest {
      public static void main(String[] args) {
          java.lang.String str = new java.lang.String();
          System.out.println("hello,atguigu.com");
  
          StringTest test = new StringTest();
          System.out.println(test.getClass().getClassLoader());
      }
  }
  ```

  **结果：**

  ​			hello,atguigu.com

  ​			sun.misc.Launcher$AppClassLoader@18b4aac2

  从运行的结果看，是不会运行我们自定义的String的，原因就是因为双亲委派机制。

* 双亲委派机制

  <img src="images/58.png" alt="img" style="zoom:65%;" />

  <img src="images/59.png" alt="img" style="zoom:75%;" />

  * 优势

    * 避免类的重复加载

    * 保护程序安全，防止核心API被随意篡改

      * 自定义类：java.lang.String

      * 自定义类：java.lang.ShkStart

        ```java
        package java.lang;
        
        public class ShkStart {
            public static void main(String[] args) {
                System.out.println("hello!");
            }
        }
        ```

        **结果：**

        ![img](images/60.png)

  * 沙箱安全机制

    * 自定义String类，但是在加载自定义String类的时候回率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<font color=red>**沙箱安全机制**</font>。

### 6 其他

* 在JVM中表示两个class对象是否为同一个类存在两个必要条件：

  * 类的完整名必须相同，包括包名。
  * 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。

* 换句话说，在JVM中，即使两个类对象（class对象）来源于同一个class文件，被同一个虚拟机所加载，但只要加载他们的ClassLoader实例对象不同，那么这两个类对象也是不同的。

* 对加载器的引用

  * JVM必须知道一个类型是由启动类加载器加载还是用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会<font color=red>**将这个类加载器的一个引用作为类型信息的一部分保存在方法区中**</font>。当解析一个类型到另一个类型的引用的时候，JVN需要保证这两个类型的类加载器时相同的。

* 类的主动使用和被动使用

  <img src="images/61.png" alt="img" style="zoom:70%;" />

## 第3章 运行时数据区

### 1 概述

<img src="images/62.png" alt="img" style="zoom:75%;" />

<img src="images/63.png" alt="img" style="zoom:65%;" />

* 内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<font color=red>**不同的JVM对于内存的划分方式和管理机制存在着部分差异**</font>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。

<img src="images/64.png" alt="img" style="zoom:60%;" />

<img src="images/65.png" alt="img" style="zoom:60%;" />

<img src="images/66.png" alt="img" style="zoom:60%;" />

* GC调优95%都在堆区，5%在方法区（JDK8之前叫做永久代，JDK8及以后叫做元空间）

<img src="images/67.png" alt="img" style="zoom:67%;" />

### 2 线程

* 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。
* 在Hotsopt JVM里，每个线程都与操作系统的本地线程直接映射。
  * 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。
* 操作系统负责所有线程的安排调度到任何一个可用的CPU熵。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。

<img src="images/68.png" alt="img" style="zoom:67%;" />

## 第4章 程序计数器（PC寄存器）



### 1 PC Register介绍

* 虚拟机规范：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.1

<img src="images/70.png" alt="img" style="zoom:75%;" />

<img src="images/71.png" alt="img" style="zoom:65%;" />

* PC寄存器是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的内存区域。
* 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。
* 任何时间一个线程都只有一个方法在执行，也就是所谓的<font color=red>**当前方法**</font>。程序计数器会存储当前线程正在执行的Java指令地址；或者，如果是在执行native方法，则是未指定值（undefined）。
* PC寄存器是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
* 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。
* 它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

### 2 举例说明

<img src="images/72.png" alt="img" style="zoom:75%;" />

<img src="images/73.png" alt="img" style="zoom:75%;" />

### 3 两个常见问题

<img src="images/74.png" alt="img" style="zoom:75%;" />

<img src="images/75.png" alt="img" style="zoom:75%;" />

* 时间片

  <img src="images/76.png" alt="img" style="zoom:75%;" />

## 第5章 虚拟机栈

### 1 虚拟机栈概述

* 官网：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.2

  <img src="images/77.png" alt="img" style="zoom:67%;" />

* 虚拟机栈出现的背景

  * 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。
  * <font color=red>**优点是扩平台，指令集小，编译器容易实现；缺点是性能下降，实现同样的功能需要更多的指令**</font>。

* 初步印象：有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存理解为仅有Java堆（heap）和Java栈（stack）,为什么？因为C语言就是这样划分的

* 内存中的栈和堆

  <img src="images/78.png" alt="img" style="zoom:67%;" />

* 虚拟机栈基本内容

  * Java虚拟机栈是什么？
    * Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame）
    * 是线程私有的
  * 声明周期：与线程一致。
  * 作用：主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。
    * 局部变量  *vs*  成员变量（或属性）
    * 基本数据类型  *vs*  引用数据类型（类、数组、接口）

  <img src="images/79.png" alt="img" style="zoom:60%;" />

  * 栈的特点（优点）

    <img src="images/80.png" alt="img" style="zoom:67%;" />

    对于程序寄存器：不存在GC、不存在OOM

    对于虚拟机栈：不存在GC、只存在OOM

    对于堆和方法区：存在GC、存在OOM

* 面试题：开发中遇到的异常有哪些？

  * 空指针异常、数组越界异常、类型转换异常等

  * 虚拟机栈中可能存在的异常

    * Java虚拟机规范允许<font color=red>**Java虚拟机栈的大小是动态的或者是固定不变的**</font>。

      * 如果采用固定大小的Java虚拟机栈，那么每一个线程的Java虚拟机栈容量容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<font color=red>**StackOverflowError**</font>异常。
      * 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程的时候没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个<font color=red>**OutOfMemoryError**</font>异常。

    * StackOverflowError演示

      ```java
      public class StackErrorTest {
          private static int count = 1;
          public static void main(String[] args) {
              main(args);
          }
      }
      ```

      <img src="images/81.png" alt="img" style="zoom:70%;" />

* 设置栈内存大小

  * 我们可以使用参数-Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度

  * 参考网址：https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE

  * idea设置运行时参数：Run--->Edit Configurations    找到当前程序，在VM options中写入参数即可

    <img src="images/82.png" alt="img" style="zoom:67%;" />

### 2 栈的存储单位

* 栈中存储什么？

  * 每个线程都有自己的栈，栈中的数据都是以<font color=red>**栈帧（Stack Frame）**</font>的格式存在。
  * 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。
  * 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

* 复习

  * OOP的基本概念：类、对象
  * 类中的基本结构：field（属性、字段、域）、method

* 栈运行原理

  * JVM直接对Java栈的操作只有两个，就是对栈帧的<font color=red>**入栈**</font>和<font color=red>**出栈**</font>，遵循<font color=blue>**"先进后出"/“后进先出”原则**</font>。

  * 在一条活动现场中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<font color=red>**当前栈帧（Current Frame）**</font>，与当前栈帧对应的方法就是<font color=red>**当前方法（Current Method）**</font>，定义这个方法的类就是<font color=red>**当前类（Current Class）**</font>。

    <img src="images/83.png" alt="img" style="zoom:67%;" />

  * 执行引擎运行的所有字节码指令只针对当前栈帧操作。

  * 如果在改方法中调用了其他方法，对应的新的栈帧就会被创建出来，放在栈的顶端，称为新的当前帧。

  * 不同线程中锁包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。

  * 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会对齐当前栈帧，使得前一个栈帧重新成为当前栈帧。

  * Java方法有两种放回函数的方式，<font color=red>**一种是正常的函数返回，使用return指令**</font>；<font color=red>**另一种是抛出异常**</font>。不管使用哪种方式，都会导致栈帧被弹出。

* 栈帧的内部结构

  * <font color=red>**局部变量表（Local Variables）**</font>

  * <font color=red>**操作数栈（Operand Stack）（或表达式栈）**</font>

  * 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）

  * 方法返回地址（Return Address）（或方法长长退出或者异常退出的定义）

  * 一些附加信息

    <img src="images/84.png" alt="img" style="zoom:67%;" />

    <img src="images/85.png" alt="img" style="zoom:67%;" />

### <font color=red>**3 局部变量表**</font>

* 局部变量表也被称为 **局部变量数组** 或 **本地变量表**

* <font color=red>**定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**</font>，这些数据类型包括各种基本数据类型、对象引用（reference），以及returnAddress类型。

* 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<font color=red>**不存在数据安全问题**</font>

* <font color=red>**局部变量表所需要的容量大小是在编译期（前端编译）确定下来的**</font>，并保存在方法的Code属性的maximun local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。

* 代码演示（代码1）

  ```java
  public class LocalVariablesTest {
      private int count = 0;
  
      public static void main(String[] args) {
          LocalVariablesTest test = new LocalVariablesTest();
          int num = 10;
          test.test1();
      }
  
      // 练习：
      public static void testStatic() {
          LocalVariablesTest test = new LocalVariablesTest();
          Date date = new Date();
          int count = 10;
          System.out.println(count);
          // 因为this变量不存在于当前方法的局部变量表中！！
          // System.out.println(this.count);
      }
  
      //关于Slot的使用的理解
      public LocalVariablesTest() {
          this.count = 1;
      }
  
      public void test1() {
          Date date = new Date();
          String name1 = "atguigu.com";
          test2(date, name1);
          System.out.println(date + name1);
      }
  
      public String test2(Date dateP, String name2) {
          dateP = null;
          name2 = "songhongkang";
          double weight = 130.5;  // 占据两个slot
          char gender = '男';
          return dateP + name2;
      }
  
      public void test3() {
          this.count++;
      }
  
      public void test4() {
          int a = 0;
          {
              int b = 0;
              b = a + 1;
          }
          // 变量c使用之前已经销毁的变量b占据的slot的位置
          int c = a + 1;
      }
  
      /*
      变量的分类：按照数据类型分：① 基本数据类型  ② 引用数据类型
                按照在类中声明的位置分：① 成员变量：在使用前，都经历过默认初始化赋值
                                                类变量： linking的prepare阶段：给类变量默认赋值  ---> initial阶段：给类变量显式赋值即静态代码块赋值
                                                实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值
                                       ② 局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过
       */
      public void test5Temp() {
          int num;
          // System.out.println(num);  // 错误信息：变量num未进行初始化
      }
  }
  ```

  <img src="images/86.png" alt="img" style="zoom:70%;" />

  <img src="images/87.png" alt="img" style="zoom:90%;" />

  我们可以看到局部变量表的大小为3（Maximum local variables）

* <font color=red>**方法嵌套调用的次数由栈的大小决定**</font>。一般来说，栈越大，方法嵌套调用的次数越多。对于一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧越大，以满足方法调用锁需要传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用的次数会减少。

* <font color=red>**局部变量表中的变量只在当前方法中有效**</font>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<font color=red>**当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁**</font>。

* 字节码内部结构剖析：依据代码1

  <img src="images/88.png" alt="img" style="zoom:95%;" />

  <img src="images/89.png" alt="img" style="zoom:95%;" />

  <img src="images/90.png" alt="img" style="zoom:95%;" />

  <img src="images/91.png" alt="img" style="zoom:95%;" />

* 关于Slot的理解

  * 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。

  * 局部变量表，<font color=red>**最基本的存储单元是Slot（变量槽）**</font>

  * 局部变量表中存放编译（前端编译）期可知的各种数据类型（8种），引用类型（reference），returnAddress类型的变量。

  * 在局部变量表里，<font color=red>**32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot**</font>.

    * byte、short、char在存储前转化为int，boolean也被转换成int，0表示false，非0表示true。

    * long 和double则占据两个Slot

      <img src="images/92.png" alt="img" style="zoom:67%;" />

* 关于非静态方法（实例方法）和构造函数局部变量表中的this

  <img src="images/93.png" alt="img" style="zoom:95%;" />

  <img src="images/93.png" alt="img" style="zoom:94%;" />

* 关于long和double占用两个slot

  <img src="images/95.png" alt="img" style="zoom:95%;" />

* Slot的重复利用

  * <font color=red>**栈帧中的局部变量表中的曹魏是可以重复利用的**</font>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的曹魏，从而<font color=red>**达到节省资源的目的**</font>。

  <img src="images/96.png" alt="img" style="zoom:95%;" />

* 变量的分类方式

  * 按照数据类型分：① 基本数据类型  ② 引用数据类型
  * 按照在类中声明的位置分：
    * ① 成员变量：在使用前，都经历过默认初始化赋值
      * 类变量： linking的prepare阶段：给类变量默认赋值  ---> initial阶段：给类变量显式赋值即静态代码块赋值
      * 实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值
    * ② 局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过

* 补充说明

  * 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机栈使用局部变量表完成方法的传递。
  * <font color=red>**局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量直接或间接引用的对象都不会被回收**</font>。

### <font color=red>**4 操作数栈（Operand Stack）**</font>

* 栈的实现：可以使用数组或链表来实现，JVM中的操作数栈使用数组实现

* 每一个独立的栈帧处理包含局部变量表以外，还包含一个<font color=red>**后进先出**</font>（Last - In - First Out）的操作数栈，也可以称之为<font color=red>**表达式栈**</font>（Expression Stack）。

* <font color=red>**操作数栈：在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）**</font>。

  * 某些字节码指令将值亚茹操作数栈，其余的字节码指令将操作数取出栈。使用它们后再将结果压入栈。

  * 比如：执行赋值、交换、求和等操作

    <img src="images/97.png" alt="img" style="zoom:67%;" />

* 操作数栈：<font color=red>**主要用于保存计算过程的中间结果，同时作为计算过程中的变量临时的存储空间**</font>。

* 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<font color=red>**这个方法的操作栈式空的**</font>。

* 每一个操作数栈都会拥有一个明确的站深度用于存储数值，其所需的最大深度在<font color=red>**编译期间（前端编译）**</font>就定义好了，保存在方法的Code属性中，为max_stack的值。

  <img src="images/98.png" alt="img" style="zoom:80%;" />

* 栈中的任意一个元素都可以是任意类型的Java数据类型。

  * 32bit的类型占用一个栈单位深度
  * 64bit的类型占用两个栈单位深度

* 操作数栈<font color=red>**并非采用访问索引的方式来进行数据访问的**</font>，而是只能通过标准的入栈和出栈操作来完成数据的一次数据访问。

* <font color=red>**如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中**</font>，并更新PC寄存器中下一条需要执行的字节码指令。

  <img src="images/104.png" alt="img" style="zoom:87%;" />

* 操作数栈中元素的数据类型必须与字节码的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。

* 另外，我们说Java虚拟机的<font color=red>**解释引擎是基于栈的执行引擎**</font>，其中的栈指的就是操作数栈。

### 5 代码追踪

```java
public class OperandStackTest {
    public void testAddOperation() {
        //byte、short、char、boolean：都以int型来保存
        byte i = 15;
        int j = 8;
        int k = i + j;
    }
}
```

javap解析后的结果如下：

<img src="images/99.png" alt="img" style="zoom:77%;" />

<img src="images/100.png" alt="img" style="zoom:67%;" />

<img src="images/101.png" alt="img" style="zoom:67%;" />

<img src="images/102.png" alt="img" style="zoom:67%;" />

<img src="images/103.png" alt="img" style="zoom:67%;" />

* 程序员面试过程中， 常见的i++和++i 的区别，放到字节码篇章时再介绍。

  ```java
  public class OperandStackTest {
      public void add(){
          //第1类问题：
          int i1 = 10;
          i1++;
  
          int i2 = 10;
          ++i2;
  
          //第2类问题：
          int i3 = 10;
          int i4 = i3++;
  
          int i5 = 10;
          int i6 = ++i5;
  
          //第3类问题：
          int i7 = 10;
          i7 = i7++;
  
          int i8 = 10;
          i8 = ++i8;
  
          //第4类问题：
          int i9 = 10;
          int i10 = i9++ + ++i9;
      }
  }
  ```

### 6 栈顶缓存（Top - of - Stack Cashing）技术

* 前面提过,基于栈式架构的虚拟机所使用的零地址指令更加紧凑,但完成一项操作的时候必须需要使用更多的入栈和出栈指令,这同时也就意味着将需要更多的指令分派(instruction dispatch)次数和内存读/写次数。
* 由于操作数是存储在内存中的,因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题,HotSpot JVM的设计者提出了栈顶缓存(ToS, Top-of-Stack Cashing)技术，**将栈顶元素全部缓存在物理CPU的寄存器中,以此降低对内存的读/写操作,提升执行引擎的执行效率。**

### <font color=red>**7 动态链接**</font>

<img src="images/105.png" alt="img" style="zoom:67%;" />

如上图，我们已经讲过了 **局部变量表** 和 **操作数栈**

* 动态链接：又称为指向运行时常量池的方法引用

  * 每一个栈帧内部都包含一个指向<font color=blue>**运行时常量池**</font>中<font color=red>**该栈帧所属方法的引用**</font>。包含这个引用的目的就是为了支持当前方法能够实现<font color=red>**动态链接（Dynamic Linking）**</font>。比如invokedynamic指令

  * 在Java原文件被编译成字节码文件中，所有的变量和方法引用都作为符号引用（Symbolic Referemce）保存在class文件的常量池里。比如：描述一个方法掉调用了另外的方法时，就是通过常量池中指向这些方法的符号引用来表示的，那么<font color=red>**动态链接的做作用就是为了将这些符号引用转换为调用方法的直接引用**</font>。

    ```java
    public class DynamicLinkingTest {
    
        int num = 10;
    
        public void methodA(){
            System.out.println("methodA()....");
        }
    
        public void methodB(){
            System.out.println("methodB()....");
            methodA();
            num++;
        }
    }
    ```

    <img src="images/106.png" alt="img" style="zoom:77%;" />

    <img src="images/107.png" alt="img" style="zoom:77%;" />

* 动态链接图解

  <img src="images/108.png" alt="img" style="zoom:67%;" />

* 动态链接的优点

  * 节省空间，因为多个动态链接可能指向同一个引用
  * 方便动态的实现，编写的时候是父类，运行的时候是子类，方便对子类的调用

* 为什么需要常量池呢？

  * 节省存储，否则编译出的.class文件会很大
  * 提供一些符号和常量，便于指令的识别

### 8 方法的调用：解析与分派

* 在JVM中，将符号引用转化为调用方法的直接引用于方法的绑定机制相关。

  * <font color=red>**动态链接：**</font>
    * 当一个字节码文件被装在近JVM内部时，如果调用的目标方法在<font color=blue>**编译期间（后端编译）**</font>可知，且运行期间保持不变。这种情况下将调用方法的符号引用转为直接引用的过程称之为静态链接。
  * <font color=red>**静态链接：**</font>
    * 如果被调用的方法在编译期间（后端编译）无法被确定下来，也就是说，只能够在程序<font color=blue>**运行期间**</font>将调用的符号引用转为直接引用，由于这种转换过程具备动态性，因此也被称之为动态链接

* 对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法、类在符号引用被替换成直接引用的过程，这仅仅发生一次。

  * <font color=red>**早期绑定：**</font>
    * 早期绑定就是指被调用的目标方法如果在<font color=blue>**编译期间（后端编译）**</font>可知，且运行期间保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用被替换成直接引用。
  * <font color=red>**晚期绑定：**</font>
    * 如果被调用的方法在编译期间（后端编译）无法被确定下来，只能够在程序<font color=blue>**运行期间**</font>根据实际的类型绑定相关的方法，这种绑定方式被称之为晚期绑定。

  ```java
  class Animal {
      public void eat() {
          System.out.println("动物进食");
      }
  }
  
  interface Huntable {
      void hunt();
  }
  
  class Dog extends Animal implements Huntable {
      @Override
      public void eat() {
          System.out.println("狗吃骨头");
      }
  
      @Override
      public void hunt() {
          System.out.println("捕食耗子，多管闲事");
      }
  }
  
  class Cat extends Animal implements Huntable {
  
      public Cat() {
          super();  // 表现为：早期绑定  invokespecial
      }
  
      public Cat(String name) {
          this();  // 表现为：早期绑定  invokespecial
      }
  
      @Override
      public void eat() {
          super.eat();  // 表现为：早期绑定  invokespecial
          System.out.println("猫吃鱼");
      }
  
      @Override
      public void hunt() {
          System.out.println("捕食耗子，天经地义");
      }
  }
  
  public class AnimalTest {
      public void showAnimal(Animal animal) {
          animal.eat();  // 表现为：晚期绑定  invokevirtual
      }
  
      public void showHunt(Huntable h) {
          h.hunt();  // 表现为：晚期绑定  invokevirtual
      }
  }
  ```

* 随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是支持<font color=red>**封装、继承、多态**</font>等面向对象特性，既然<font color=red>**这一类编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式**</font>。

* Java中的任何一个普通方法（不用static修饰，或final修饰）其实都具备虚函数的特征，他们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果Java程序不希望某个方法拥有虚函数特征时，则可以使用final来标记这个方法。

* 虚方法和非虚方法

  * 非虚方法
    * 如果方法在编译期间就确定了具体的调用版本，这个版本在运行时时不可变的。这样的方法属于<font color=red>**非虚方法**</font>。
    * 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
  * 虚方法：其他的都为虚方法。

* 虚拟机中提供 了以下几条方法调用指令：

  * 普通调用指令
    1. invokestatic：调用静态方法，解析阶段确定唯一方法版本
    2. invokespecial：调用\<init>方法、私有及父类方法，解析阶段确定唯一版本
    3. invokevirtual：调用所有的虚方法
    4. invokeinterface：调用接口方法
  * 动态调用指令
    5. invokedynamic：动态解析出需要调用放入方法，然后执行

  前四条指令固话在虚拟机内部，方法的调用执行不可认为敢于，而invokedynamic指令则支持用户确定方法版本，其中<font color=red>**invokestatic和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法**</font>。

  ```java
  /**
   * 解析调用中非虚方法、虚方法的测试
   * invokestatic指令和invokespecial指令调用的方法称为非虚方法
   */
  class Father {
      public Father() {
          System.out.println("father的构造器");
      }
  
      public static void showStatic(String str) {
          System.out.println("father " + str);
      }
  
      public final void showFinal() {
          System.out.println("father show final");
      }
  
      public void showCommon() {
          System.out.println("father 普通方法");
      }
  }
  
  public class Son extends Father {
      public Son() {
          //invokespecial
          super();
      }
  
      public Son(int age) {
          //invokespecial
          this();
      }
  
      //不是重写的父类的静态方法，因为静态方法不能被重写！
      public static void showStatic(String str) {
          System.out.println("son " + str);
      }
  
      private void showPrivate(String str) {
          System.out.println("son private" + str);
      }
  
      public void show() {
          //invokestatic
          showStatic("atguigu.com");
          //invokestatic
          super.showStatic("good!");
          //invokespecial
          showPrivate("hello!");
          //invokespecial
          super.showCommon();
  
          //invokevirtual
          showFinal();//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。
          //虚方法如下：
          //invokevirtual
          showCommon();
          info();
  
          MethodInterface in = null;
          //invokeinterface
          in.methodA();
      }
  
      public void info() { }
  
      public void display(Father f) { f.showCommon(); }
  
      public static void main(String[] args) {
          Son so = new Son();
          so.show();
      }
  }
  
  interface MethodInterface {
      void methodA();
  }
  ```

* 关于invokedynamic指令

  * JVM字节码指令集一致比较稳定，直到Java7中才增加了一个invokedynamic指令，这是<font color=red>**Java为了实现[动态类型语言]支持而做的一种改进**</font>。
  * 但是在Java7中并没有直接生成invokedynamic指令，需要借助ASM这种底层字节码工具来产生invokedynamic指令。<font color=blue>**直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式**</font>。
  * Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。
  * 动态类型语言 *vs.* 静态类型语言
    * 动态类型语言：对于变量类型的检查在编译期间；
    * 静态类型语言：对于变量类型的检查在运行期间；
    * 说的再直白一点就是，<font color=blue>**静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，**</font>这是动态语言的一个重要特征。

  ```java
  /**
   * 体会invokedynamic指令
   */
  @FunctionalInterface
  interface Func {
      public boolean func(String str);
  }
  
  public class Lambda {
      public void lambda(Func func) {
          return;
      }
  
      public static void main(String[] args) {
          Lambda lambda = new Lambda();
  
          Func func = s -> {
              return true;
          };
  
          lambda.lambda(func);
  
          lambda.lambda(s -> {
              return true;
          });
      }
  }
  ```

  <img src="images/109.png" alt="img" style="zoom:97%;" />

* 方法重写的本质

  * Java语言中方法重写的本质
    1. 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。
    2. 如果在在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。
    3. 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
    4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。
  * IllegalAccessError介绍
    * 程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，则说明一个类发生了不兼容的改变。

* 虚方法表

  * 在面向对象的编程中，会很频繁的使用到动态分派，如果每次动态分派的过程找那个都要重新在类的方法元数据区中搜索合适的目标的话就可能影响到执行效率。因此，<font color=blue>**为了提高性能，**</font>JVM采用在类的方法区建立一个虚方法表<font color=red>**(virtual method table)(非虚方法不会出现在表中)来实现**</font>。使用索引表来代替查找。

  * 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。

  * 那么虚方法表什么时候被创建？

    * 虚方法表会在类加载子系统的第二大阶段（链接阶段）中的第三小阶段（解析）被创建并开始初始化，类变量初始化准备完成之后，JVM会把该类的方法表也初始化完毕。

  * 举例1

    <img src="images/110.png" alt="img" style="zoom:67%;" />

  * 举例2

    ```java
    /**
     * 虚方法表的举例
     */
    interface Friendly {
        void sayHello();
        void sayGoodbye();
    }
    
    class Dog {
        public void sayHello() { }
        public String toString() { return "Dog"; }
    }
    
    class Cat implements Friendly {
        public void eat() { }
        public void sayHello() { }
        public void sayGoodbye() { }
        protected void finalize() { }
        public String toString(){ return "Cat"; }
    }
    
    class CockerSpaniel extends Dog implements Friendly {
        public void sayHello() { super.sayHello(); }
        public void sayGoodbye() { }
    }
    
    public class VirtualMethodTable {
    }
    ```

    <img src="images/111.png" alt="img" style="zoom:67%;" />

    Dog：

    <img src="images/112.png" alt="img" style="zoom:67%;" />

    CockerSpaniel

    <img src="images/113.png" alt="img" style="zoom:67%;" />

    Cat

    <img src="images/114.png" alt="img" style="zoom:67%;" />

### <font color=red>**9 方法返回地址（return address）**</font>

* 存放调用该方法的pc寄存器的值。

* 一个方法的结束，有两种方式：

  * 正常执行完成
  * 出现未处理的异常，非正常退出

* 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<font color=red>**调用者的pc寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址**</font>。而通过异常退出的，返回地址时要通过异常表来确定，栈帧一般不会保存这部分信息。

* 当一个方法开始执行后，只有两种方式可以退出这个方法：

  1. 执行引擎遇到一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<font color=red>**正常完成出口**</font>。

     * 一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。
     * 在字节码指令中，返回指令包含ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn以及areturn，另外还有一个return指令工声明为void的方法、实例初始化方法、雷和接口的初始化方法使用。

  2. 在方法执行过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<font color=red>**异常完成出口**</font>。

     * 方法执行过程中抛出异常的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。

     <img src="images/115.png" alt="img" style="zoom:80%;" />

* 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。

* <font color=red>**正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何返回值**</font>。

### 10 一些附加信息

* 栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。

### 11 栈的相关面试题

* 举例栈溢出的情况？

  * 栈溢出报错：StackOverflowError；
  * 通过-Xss设置栈的大小；
  * 若栈的大小是动态变化的，当因为内存限制无法扩容时，会报出OutOfMemoryError错误。

* 调整栈大小，就能保证不出现溢出吗？

  * 不能，比如递归调用没有终止条件。

* 分配的栈内存越大越好吗？

  * 不是，栈大了其他内容就小了

* 垃圾回收是否会涉及到虚拟机栈？

  * 垃圾回收不会涉及到虚拟机栈
  * 扩展
    * 对于程序寄存器：不存在GC、不存在OOM
    * 对于虚拟机栈和本地方法栈：不存在GC、只存在OOM
    * 对于堆和方法区：存在GC、存在OOM

* 方法中定义的局部变量是否是线程安全？

  * 具体问题具体分析

  * 例子

    ```java
    /**
     * 面试题：
     * 方法中定义的局部变量是否线程安全？具体情况具体分析
     * 
     * 何为线程安全？
     * 如果只有一个线程才可以操作此数据，则必是线程安全的。
     * 如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。
     *
     */
    public class StringBuilderTest {
    
        int num = 10;
    
        // s1的声明方式是线程安全的
        public static void method1() {
            // StringBuilder:线程不安全
            StringBuilder s1 = new StringBuilder();
            s1.append("a");
            s1.append("b");
            // ...
        }
    
        // sBuilder的操作过程：是线程不安全的
        public static void method2(StringBuilder sBuilder) {
            sBuilder.append("a");
            sBuilder.append("b");
            // ...
        }
    
        // s1的操作：是线程不安全的
        public static StringBuilder method3() {
            StringBuilder s1 = new StringBuilder();
            s1.append("a");
            s1.append("b");
            return s1;
        }
    
        // s1的操作：是线程安全的
        public static String method4() {
            StringBuilder s1 = new StringBuilder();
            s1.append("a");
            s1.append("b");
            return s1.toString();
        }
    
        public static void main(String[] args) {
            StringBuilder s = new StringBuilder();
            
            new Thread(() -> {
                s.append("a");
                s.append("b");
            }).start();
    
            method2(s);
            System.out.println(s);
        }
    }
    ```


## 第6章 本地方法接口

<img src="images/116.png" alt="img" style="zoom:67%;" />

* 什么是本地方法？

  * 简单地讲，<font color=blue>**一个Native Method就是一个Java调用非Java代码的接口**</font>。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其他的编译语言都有这一机制，比如在C++中，你可以用extern "C"告知C++编译器去调用一个C的函数。
  * “A native method is a Java method whose implementation is provided by nono-java code.”
  * 在定义一个native method时，并不提供实现体（有些像定义一个Java的interface），因为其实现体是由非Java语言在外面实现的。
  * 本地方法的作用是融合不同编程语言为Java所用，它的初衷是融合C/C++程序。

* 代码演示

  ```java
  public class IHaveNatives {
      public native void Native1(int x);
  
      public native static long Native2();
  
      private native synchronized float Native3(Object o);
  
      native void Native4(int[] ary) throws Exception;
  }
  ```

  标识符native可以与所有其他的java标识符连用，但是abstract除外。

* 为什么要使用Native Method？

  * Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。
  * **与Java环境外交互**
    * <font color=red>**优势Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因**</font>。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正式这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。
    * **与操作系统交互：**
      * JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。<font color=red>**通过使用这些本地方法，我们得以用Java实现jre的与底层的交互，甚至JVM的一些部分就是C写的**</font>。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。
    * Sun's Java
      * <font color=red>**Sun的解释器 使用C实现的，这使得它能像一些普通的C一样与外部交互**</font>。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现的是该类的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setPriority()API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。

* 现状

  * <font color=red>**目前该方法是用的越来越少了，除非是与硬件有关的应用**</font>，比如通过Java程序确定打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域键的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。

## 第7章

<img src="images/117.png" alt="img" style="zoom:67%;" />

<img src="images/118.png" alt="img" style="zoom:67%;" />

<img src="images/119.png" alt="img" style="zoom:67%;" />

## 第8章 堆

* 整个系列学习路线

<img src="images/120.png" alt="img" style="zoom:67%;" />

### 1 堆的核心概述

<img src="images/121.png" alt="img" style="zoom:67%;" />

* 每个进程对应一个JVM实例，对应一个Runtime；一个进程对应多个线程，一个线程对应一个程序计数器、虚拟机栈、本地方法栈。一个进程中的线程要共享堆空间和方法区

* 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域，演示如下：

  ```java
  /**
   * -Xms10m -Xmx10m
   */
  public class HeapDemo {
      public static void main(String[] args) {
          System.out.println("start...");
          try {
              Thread.sleep(1000000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println("end...");
      }
  }
  ```

  ```java
  /**
   * -Xms20m -Xmx20m
   */
  public class HeapDemo1 {
      public static void main(String[] args) {
          System.out.println("start...");
          try {
              Thread.sleep(1000000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println("end...");
      }
  }
  ```

  运行程序后，使用jdk8自带的jvisualvm.exe查看程序的详细信息

  <img src="images/122.png" alt="img" style="zoom:95%;" />

  <img src="images/123.png" alt="img" style="zoom:90%;" />

  <img src="images/124.png" alt="img" style="zoom:95%;" />

  <img src="images/125.png" alt="img" style="zoom:95%;" />

* Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间

  * 堆内存的大小是可以调节的

* 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存够空间中，但是逻辑上它应该被视为连续的。

* 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB），这样可以提高并发性

---

* 《Java虚拟机规范》中对Java堆的描述是：<font color=red>**所有的对象实例以及数组**</font>都应当在运行时分配到堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）

  * 我要说的是：“几乎”所有的对象实例都是在堆上分配内存。------从实际使用角度看的。

* 数组和对象可能永远不会存储在沾上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。

* 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收的时候才会被移除。

* 堆，是GC（Garbage Collection）执行垃圾回收的重点区域

* 代码演示

  ```java
  public class SimpleHeap {
      private int id;  // 属性、成员变量
  
      public SimpleHeap(int id) {
          this.id = id;
      }
  
      public void show() {
          System.out.println("My ID is " + id);
      }
  
      public static void main(String[] args) {
          SimpleHeap sl = new SimpleHeap(1);
          SimpleHeap s2 = new SimpleHeap(2);
  
          int[] arr = new int[10];
          Object[] arr1 = new Object[10];
      }
  }
  ```

  <img src="images/126.png" alt="img" style="zoom:67%;" />

  <img src="images/127.png" alt="img" style="zoom:77%;" />

---

* 内存细分

  <img src="images/128.png" alt="img" style="zoom:67%;" />

  * 堆空间内部结构（JDK7）

    <img src="images/129.png" alt="img" style="zoom:67%;" />

    <img src="images/131.png" alt="img" style="zoom:87%;" />

  * 堆空间内部结构（JDK8）

    <img src="images/130.png" alt="img" style="zoom:67%;" />

    对于前面的SimpleHeap，设置参数：-Xms10m -Xmx10m -XX:+PrintGCDetails	运行后的结果如下：

    <img src="images/132.png" alt="img" style="zoom:87%;" />

### 2 设置堆内存大小与OOM

* 堆空间大小的设置

  * Java堆空间用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项“-Xms”和"-Xmx"来进行设置。

    * “-Xms”用于标识堆区的起始内存，等价于-XX:InitialHeapSize
    * “-Xmx”则用于标识堆区的最大内存，等价于-XX:MaxHeapSize

  * 一旦堆区的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError异常。

  * 通常会将“-Xms”和“-Xmx”两个参数设置成相同的值，其<font color=red>**目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能**</font>。

  * 默认情况下，初始内存大小：物理电脑内存大小 / 64

    ​						最大内存大小：物理电脑内存大小 / 4

  ```java
  /**
   * 1. 设置堆空间大小的参数
   * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小
   *      -X 是jvm的运行参数
   *      ms 是memory start
   * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小
   *
   * 2. 默认堆空间的大小
   *    初始内存大小：物理电脑内存大小 / 64
   *             最大内存大小：物理电脑内存大小 / 4
   * 3. 手动设置：-Xms600m -Xmx600m
   *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。原因是扩容缩容会造成服务器不必要的压力
   *
   * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id
   *                  方式二：-XX:+PrintGCDetails
   */
  public class HeapSpaceInitial {
      public static void main(String[] args) {
  
          // 返回Java虚拟机中的堆内存总量
          long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;
          // 返回Java虚拟机试图使用的最大堆内存量
          long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;
  
          System.out.println("-Xms : " + initialMemory + "M");
          System.out.println("-Xmx : " + maxMemory + "M");
  
          System.out.println("系统内存大小为：" + initialMemory * 64.0 / 1024 + "G");
          System.out.println("系统内存大小为：" + maxMemory * 4.0 / 1024 + "G");
  
          try {
              Thread.sleep(1000000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      }
  }
  ```

  **如果没有设置任何参数，则结果：**

  ​			-Xms : 245M

  ​			-Xmx : 3614M

  ​			系统内存大小为：15.3125G

  ​			系统内存大小为：14.1171875G

  **如果设置参数-Xms600m -Xmx600m，此时值关注前两项结果：**

  ​			-Xms : 575M

  ​			-Xmx : 575M

  <img src="images/133.png" alt="img" style="zoom:100%;" />

  不是600M，因为幸存者区有两个，但是只计算了一个

  (25600+25600+153600+409600) / 1024 = 600M

  (25600+153600+409600) / 1024 = 575M

  <img src="images/134.png" alt="img" style="zoom:90%;" />

* OOM：OutOfMemoeyError

  <img src="images/135.png" alt="img" style="zoom:80%;" />

  * 代码演示

  ```java
  public class OOMTest {
      public static void main(String[] args) {
          ArrayList<Picture> list = new ArrayList<>();
          while (true) {
              try {
                  Thread.sleep(20);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              list.add(new Picture(new Random().nextInt(1024 * 1024)));
          }
      }
  }
  
  class Picture {
      private byte[] pixels;
  
      public Picture(int length) {
          this.pixels = new byte[length];
      }
  }
  ```

  **结果：**

  <img src="images/136.png" alt="img" style="zoom:80%;" />

  <img src="images/137.png" alt="img" style="zoom:80%;" />

### 3 年轻代与老年代

* 存储在JVM中的Java对象可以被划分为两类：
  * 一类是声明周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
  * 另一类对象的声明周期非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。
* Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）
* 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区，谁空谁为to区）

<img src="images/138.png" alt="img" style="zoom:77%;" />

---

* 下面的参数开发中一般不会调：

  <img src="images/139.png" alt="img" style="zoom:77%;" />

* 配置新生代和老年代在堆结构的占比

  * 默认**-XX:NewRatio=2**，表示新生代占1，老年代占2，新生代占整个堆的1/3

  * 可以修改**-XX:NewRatio=4**，表示新生代占1，老年代占4，新生代占整个堆的1/5

  * 代码演示

    ```java
    /**
     * -Xms600m -Xmx600m
     *
     * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2.
     * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8
     * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）
     * -Xmn:设置新生代的空间的大小。 （一般不设置）
     */
    public class EdenSurvivorTest {
        public static void main(String[] args) {
            System.out.println("我只是来打个酱油~");
            try {
                Thread.sleep(1000000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    ```

    <img src="images/140.png" alt="img" style="zoom:100%;" />

---

* 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1

  * 但实际上比例是6:1:1，即使关闭自适应机制（-XX:-UseAdaptiveSizePolicy）也是6:1:1，即使通过命令（jinfo -flag NewRatio）查看看到的数值是8

    <img src="images/141.png" alt="img" style="zoom:95%;" />

    <img src="images/142.png" alt="img" style="zoom:100%;" />

    想要变成8:1:1可以通过设置“-XX:SurvivorRatio=8”实现

* 当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8

* <font color=red>**几乎所有的**</font>Java对象都是在Eden去被new出来的。

  * 如果对象太大，Eden放不下，需要直接放到老年区，仍然放不下的话，会报错。

* 绝大部分Java对象的销毁都在新生代进行了。

  * IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。

* 可以使用选项“-Xmn”设置新生代最大内存大小

  * 这个参数一般使用默认值就可以了。
  * 如果这个参数和"-XX:NewRatio"产生矛盾，以“-Xmn”为准

<img src="images/143.png" alt="img" style="zoom:67%;" />

### 4 图解对象分配过程

* 概述：为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。

  1. new的对象首先放到伊甸园区。此区有大小限制。

  2. 当伊甸园区的空间填满时，程序又需创建对象，JVM的垃圾回收器会对伊甸园区进行垃圾回收（Minor GC / Young GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象到伊甸园区

  3. 然后将伊甸园区中的剩余对象移动到幸存者0区。

  4. 如果再次出发垃圾回收，此时上次幸存下来的放到幸存者0区，如果没有回收，就会放到幸存者1区。

  5. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。

  6. 啥时候能去养老区呢？可以设置次数。默认是15次。

     * <font color=red>**可以设置参数：-XX:MaxTenuringThreshold=<N>进行设置**</font>。

       <img src="images/144.png" alt="img" style="zoom:100%;" />

  7. 在养老区，相对悠闲。当养老区内存不足时，再次出发：Major GC，进行养老区的内存清理。

  8. 若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常

     * <font color=red>**java.lang.OutOfMemoryError: Java heap space**</font>

<img src="images/145.png" alt="img" style="zoom:67%;" />

* 注意点：当幸存者区满的时候不会出发Young GG；但是当伊甸园区满的时候，会出发Young GC，同时也会对幸存者区进行GC；幸存者区被动GC
* 总结：
  * <font color=red>**针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to**</font>。
  * <font color=red>**关于垃圾回收：频繁收集新生代，较少收集老年代，几乎不动永久区/元空间**</font>。

* 对象分配详细过程

<img src="images/146.png" alt="img" style="zoom:67%;" />

---

* 常用的调优工具
  * JDK命令行：jstat、jinfo、javap、jmap等命令
  * Eclipse：Memory Analyzer Tool
  * Jconsole
  * VisualVM
  * Jprofiler
  * Java Flight Recorder
  * GCViewer
  * GC Easy

### 5 Minor GC、Major GC、Full GC

* JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。
* 针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）
  * 部分收集：不是完整收集整个Java堆的垃圾收集，其中又分为：
    * 新生代收集（Minor GC / Young GC）：知识新生代（Eden / S0，S1）的垃圾收集
    * 老年代收集（Major GC / Old GC）：知只是老年代的垃圾收集。
      * 目前，只有CMS GC（一个并发的垃圾回收器）会有单独收集老年代的行为。
      * <font color=red>**注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收**</font>。
    * 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾回收
      * 目前，只有G1 GC才会有这种行为，这是由于G1是分为region的
  * 整堆回收（Full GC）：收集整个java堆和方法区的垃圾回收。

---

* 最简单的分代式GC策略的出发条件

  * 年轻代GC（Minor GC / Young GC）触发机制：
    * 当新生代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存）。
    * 因为Java对象<font color=red>**大多都具备朝生夕灭**</font>的特性，所以Minor GC会非常频繁，一般回收速度也比较快。这一定义既清晰又利于理解。
    * Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才回复运行。

  <img src="images/147.png" alt="img" style="zoom:67%;" />

  * 老年代GC（Major GC / Full GC）触发机制：
    * 指发生在老年代的GC，对象从老年代消失时，我们说"Major gc"或“Full GC"发生了。
    * 出现了Major GC，经常会伴随至少一次Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。
      * 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则会触发Major GC
    * Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。
    * 如果Major GC后，内存还不足，就报OOM了。

* Full GC触发机制：（<font color=red>**后面细讲**</font>）

  * 触发Full GC执行的情况有如下5种：
    1. 调用System.gc()时，系统建议执行Full GC，但是不必然执行
    2. 老年代空间不足
    3. 方法区空间不足
    4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
    5. 由Eden区、From Space区向To Space区复制时，对象的大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
  * 说明：<font color=red>**Full GC 是开发或调优中尽量要避免的。这样暂停时间会短一些**</font>。

---

* 代码例子

  ```java
  /**
   * 测试MinorGC 、 MajorGC、FullGC
   * -Xms9m -Xmx9m -XX:+PrintGCDetails
   */
  public class GCTest {
      public static void main(String[] args) {
          int i = 0;
          try {
              List<String> list = new ArrayList<>();
              String a = "atguigu.com";
              while (true) {
                  list.add(a);
                  a = a + a;
                  i++;
              }
          } catch (Throwable t) {
              t.printStackTrace();
              System.out.println("遍历次数为：" + i);
          }
      }
  }
  ```

  **设置参数-Xms9m -Xmx9m -XX:+PrintGCDetails后的运行效果：**

  <img src="images/148.png" alt="img" style="zoom:90%;" />

### 6 堆空间分代思想

* <font color=red>**为什么需要把Java堆分代？不分代就不能正常工作了吗？**</font>

  * 经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。
    * 新生代：有Eden、两块大小相同的Survivor（又称为from/to，s0/s1）构成，to总为空。
    * 老年代：存放新生代中经历多次GC仍然存活的对象。

  <img src="images/149.png" alt="img" style="zoom:67%;" />

  * 其实不分代完全可以，<font color=red>**分代的唯一理由就是优化GC性能。**</font>如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。

  <img src="images/150.png" alt="img" style="zoom:67%;" />

### 7 内存分配策略（对象提升（Promotion）规则）

* 如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区每熬过一个Monor GC，年龄就增加1.对象年龄增加到一定程度（默认15岁，其实每个JVM，每个GC有所不同）时，就会被晋升到老年代。

  * 对象晋升老年代的年龄阈值，可以通过选项**-XX:MaxTenuringThreshold**来设置

* 针对不同年龄段的对象分配原则如下：

  * 优先分配到Eden
  * 大对象（指大小大于Eden区总大小的对象）直接分配到老年代
    * 尽量避免程序中出现过多的大对象
    * <font color=red>**世界上最痛苦的事情是创建过多大对象，世界最最痛苦的事情是创建过多大对象并且还是朝生夕死的**</font>。
  * 长期存活的对象分配到老年代
  * 动态对象年龄判断
    * 如果Survivor区中相同年龄的所有对象的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。
  * 空间分配担保
    * -XX:HandlePromotionFailure

* 大对象直接放入老年代代码演示：

  ```java
  /** 测试：大对象直接进入老年代
   * -Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails
   * Eden : 16m ;    Survivor0 : 2m ;    Survivor1 : 2m ;    Old : 40m
   */
  public class YoungOldAreaTest {
      public static void main(String[] args) {
          byte[] buffer = new byte[1024 * 1024 * 20];  // 20m
      }
  }
  ```

  <img src="images/151.png" alt="img" style="zoom:90%;" />

### 8 为对象分配内存：TLAB

* <font color=red>**为什么有TLAB（Thread Local Allocation Buffer）？**</font>

  * 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
  * 由于对象实例的创建在JVM中非常频繁，因此开发环境下从堆区中划分内存空间是线程不安全的
  * 为避免多个线程操作统一地址，需要使用加锁等机制，进而影响分配速度。

* <font color=red>**什么是TLAB？**</font>

  * 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为<font color=red>**每个线程分配一个私有缓存区域**</font>，它包含在Eden空间中。
  * 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配策略称为<font color=red>**快速分配策略**</font>。
  * 据我所知所有的OpenJDK衍生出来的JVM都提供了TLAB的设计。

  <img src="images/152.png" alt="img" style="zoom:67%;" />

* TLAB再说明：

  * 尽管不是所有的对象实例都能够在TLAN中成功分配内存，但<font color=red>**JVM确实将TLAB作为内存分配的首选**</font>。

  <img src="images/153.png" alt="img" style="zoom:100%;" />

  * 在程序中，开发人员可以通过选项“-XX:UserTlab”设置是否开启TLAB空间。
  * 默认情况下，TLAB空间的内存非常小，<font color=red>**仅占有整个Eden空间的1%**</font>，当然我们可以通过选项“-XX:TLABWasteTargetPercent"设置TLAB空间的百分比大小。
  * 一旦对象在TLAB空间内存分配失败时，JVM就会尝试着通过<font color=red>**使用加锁机制**</font>确保数据操作的原子性，从而直接在Eden空间中分配内存。

### 9 小结堆空间的参数设置

```java
/**
 * 测试堆空间常用的jvm参数：
 * -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值
 * -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）
 *      具体查看某个参数的指令： jps：查看当前运行中的进程
 *                           jinfo -flag SurvivorRatio 进程id
 *
 * -Xms：初始堆空间内存 （默认为物理内存的1/64）
 * -Xmx：最大堆空间内存（默认为物理内存的1/4）
 * -Xmn：设置新生代的大小。(初始值及最大值)
 * -XX:NewRatio：配置新生代与老年代在堆结构的占比，默认为2
 * -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例，默认为8
 * -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄，默认为15，最大值也为15
 * -XX:+PrintGCDetails：输出详细的GC处理日志
 * 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc
 * -XX:HandlePromotionFailure：是否设置空间分配担保
 */
public class HeapArgsTest {
    public static void main(String[] args) {

    }
}
```

<img src="images/154.png" alt="img" style="zoom:90%;" />

* "-XX:SurvivorRatio"设置的过大会有什么影响？

  * 会导致s0/s1很小，以至于Minor GC的时候to区放不下，直接进入到了老年代，导致Minor GC的没有什么意义，分代也没有什么意义了。

* "-XX:SurvivorRatio"设置的过小会有什么影响？

  * 会导致Young GC过于频繁，导致STW更长，影响性能。

* “-XX:MaxTenuringThreshold”的取值范围是多少？为什么？

  * 取值范围为0~15，包含0和15，因为对象头中只有4位（bits）存放该值的信息

  * 设置参数"-XX:MaxTenuringThreshold=20"后运行性程序会出现下述错误：

    <img src="images/155.png" alt="img" style="zoom:90%;" />

* "-XX:HandlePromotionFailure"说明

  * 在发生Minor GC之前，虚拟机会<font color=red>**检查老年代最大可用的连续空间是否大于新生代所有对象的总空间**</font>。
    * 如果大于，则此次Minor GC是安全的
    * 如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败
      * 如果HandlePromotionFailure=true，那么会继续<font color=red>**检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小**</font>。
        * 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是由风险的；
        * 如果小于，则改为Full GC.
      * 如果HandlePromotionFailure=false，则改为一次Full GC
  * 在JDK6 Update24（JDK7）之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察OpenJDK中源码的变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它，JDK6 Update24之后的规则变为<font color=red>**只要老年代的连续空间大于新生代总对象大小**</font>或者<font color=red>**历次晋升的平均大小**</font>就会进行Minor GC，否则进行Full GC。

### 10 堆是分配对象的唯一选择吗？

* 首先上述答案：<font color=red>**堆不是分配对象的唯一选择**</font>。

* 在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：
  * 随着JIT编译器的发展与<font color=red>**逃逸分析技术**</font>逐渐成熟，<font color=red>**栈上分配、标量替换优化技术**</font>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不是那么“绝对”了。
* 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的尝试。但是，有一种特殊的情况，那就是<font color=red>**如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃出方法的话，那么就可能会被优化成栈上分配**</font>。这样就无需在堆上分配，也无需进行垃圾回收了。这也是最常见的对外存储技术。
* 此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisiable heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率。

---

* 逃逸分析

  * 如何将堆上的对象分配到栈，需要使用逃逸分析手段。

  * 这是一种可以有效减少Java程序中<font color=red>**同步负载和内存分配压力的跨函数全局流分析算法**</font>

  * 通过逃逸分析，Java HotSpot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

  * 逃逸分析的基本行为就是分析对象的动态作用域：

    * 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
    * 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为参数传递到其他地方中。

  * 例子

    ```java
    /**
     * 逃逸分析
     * 如何快速的判断是否发生了逃逸，大家就看new的对象实体是否有可能在方法外被调用。
     */
    public class EscapeAnalysis {
    
        public EscapeAnalysis obj;
    
        // 方法返回EscapeAnalysis对象，发生逃逸
        public EscapeAnalysis getInstance() {
            return obj == null ? new EscapeAnalysis() : obj;
        }
        
        // 为成员属性赋值，发生逃逸
        public void setObj() {
            this.obj = new EscapeAnalysis();
        }
        // 思考：如果当前的obj引用声明为static的？仍然会发生逃逸。
        
        // 对象的作用域仅在当前方法中有效，没有发生逃逸
        public void useEscapeAnalysis() {
            EscapeAnalysis e = new EscapeAnalysis();
        }
        
        // 引用成员变量的值，发生逃逸
        public void useEscapeAnalysis1() {
            EscapeAnalysis e = getInstance();
            // getInstance().xxx()同样会发生逃逸
        }
    }
    ```

  * 参数设置：

    * 在JDK 6U23版本之后，HotSpot中默认就已经开启了逃逸分析。
    * 如果使用的是较早的版本，开发人员可以通过：
      * 选项“-XX:DoEscapeAnalysis”显示开启逃逸分析
      * 通过选项“-XX:+PrintEscapeAnalysis”来查看逃逸分析的筛选结果

  * 结论：<font color=red>**开发中能使用局部变量的，就不要使用在方法外定义**</font>。

---

* 基于逃逸分析的代码优化：使用逃逸分析，编译器可以对代码做如下优化
  * <font color=red>**栈上分配**</font>。将堆分配转化为占分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是占分配的候选，而不是堆分配。
  * <font color=red>**同步省略**</font>。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
  * <font color=red>**分离对象或标量替换**</font>。有的对象可能不需要作为一个连续的存储结构存在也可以被访问到那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。对于Java来说，就是对象可以不必存储在堆空间，可以存储在栈空间。

---

* 栈上分配

  * JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后形成结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。

  * 常见的栈上分配的场景

    * 在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。

  * 代码例子：逃逸分析可以加快代码运行时间

    ```java
    /**
     * 栈上分配测试
     * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails
     */
    public class StackAllocation {
        public static void main(String[] args) {
            long start = System.currentTimeMillis();
    
            for (int i = 0; i < 10000000; i++) {
                alloc();
            }
            // 查看执行时间
            long end = System.currentTimeMillis();
            System.out.println("花费的时间为： " + (end - start) + " ms");
            // 为了方便查看堆内存中对象个数，线程sleep
            try {
                Thread.sleep(1000000);
            } catch (InterruptedException e1) {
                e1.printStackTrace();
            }
        }
    
        private static void alloc() {
            User user = new User();  // 未发生逃逸
        }
    
        static class User {
        }
    }
    ```

    **参数为“-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails”时结果：**

    ​			花费的时间为： 100 ms

    <img src="images/156.png" alt="img" style="zoom:90%;" />

    **参数为“-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails”时结果：**

    ​			花费的时间为： 5 ms

    <img src="images/157.png" alt="img" style="zoom:90%;" />

    **参数为“-Xmx256m -Xms256m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails”时结果：**

    <img src="images/158.png" alt="img" style="zoom:90%;" />

    **参数为“-Xmx256m -Xms256m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails”时结果：**

    ​			花费的时间为： 5 ms

---

* 同步省略 / 同步消除

  * 线程同步的代价是相当高的，同步的后果是降低并发性和性能。
  * 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<font color=red>**判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程**</font>。如果没有，那么JIT编译器在编译（后端编译）这个同步代码块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫作<font color=red>**锁消除**</font>。

  <img src="images/159.png" alt="img" style="zoom:67%;" />

  <img src="images/160.png" alt="img" style="zoom:80%;" />

  我们可以看到字节码文件中仍然有monitorexter和monitorexit，在运行时会被消除（JIT编译器编译（后端编译）运行时会被消除）

---

* 分离对象或标量替换

  <img src="images/161.png" alt="img" style="zoom:67%;" />

  <img src="images/162.png" alt="img" style="zoom:67%;" />

  * 标量替换参数设置：参数-XX:EliminateAllocations  开启了标量替换（默认打开），允许将对象打散分配在栈上

  * 代码演示：

    ```java
    /**
     * 标量替换测试
     *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations
     */
    public class ScalarReplace {
        public static class User {
            public int id;
            public String name;
        }
    
        public static void alloc() {
            User u = new User();  // 未发生逃逸
            u.id = 5;
            u.name = "www.atguigu.com";
        }
    
        public static void main(String[] args) {
            long start = System.currentTimeMillis();
            for (int i = 0; i < 10000000; i++) {
                alloc();
            }
            long end = System.currentTimeMillis();
            System.out.println("花费的时间为： " + (end - start) + " ms");
        }
    }
    ```

    **参数为“-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations”时结果：**

    <img src="images/163.png" alt="img" style="zoom:90%;" />

    **参数为“-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations”时结果：**

    ​			花费的时间为： 5 ms

---

* 总结

  <img src="images/164.png" alt="img" style="zoom:67%;" />

  <img src="images/165.png" alt="img" style="zoom:100%;" />

  <img src="images/166.png" alt="img" style="zoom:67%;" />

---

* 本章小结

  <img src="images/167.png" alt="img" style="zoom:67%;" />

## 第9章 方法区

### 1 栈、堆、方法区的交互关系

* 运行时数据区结构图

  <img src="images/168.png" alt="img" style="zoom:67%;" />

  <img src="images/169.png" alt="img" style="zoom:67%;" />

  <img src="images/170.png" alt="img" style="zoom:67%;" />

### 2 方法区的理解

* 官方定义

  <img src="images/171.png" alt="img" style="zoom:97%;" />

* 方法区在哪里？

  * 《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上属于堆的一部分，但一些简单的实现可能不会去进行垃圾收集或者进行压缩。”但是对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。
  * 所以，<font color=red>**方法区看做是一块独立于Java堆的内存空间。**</font>

* 方法区的基本理解

  * 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。
  * <font color=red>**方法区在JDK8之前的落地实现叫做永久代，在JDK8及以后的落地实现叫做元空间**</font>
  * 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间和Java堆一样都是可以不连续的。
  * 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。
  * 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError:PermGen space 或者 java.lang.OutOfMemoryError:Metaspace
    * 类过多的情况：加载大量的第三方jar包；Tomcat部署的工程过多（30-50个）；大量动态地生成反射类
  * 关闭JVM就会释放这个区域的内存

---

* 在JDK7及以前，习惯上把方法区称为永久代。JDK8开始，使用元空间取代了永久代。
* 本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRocket / IBM J9中不存在永久代的概念。
  * 现在来看，当前使用永久代，不是好的idea。导致Java程序更容易OOM（应为永久代使用的是JVM内存，不是本地内存，当超过-XX:MaxPermSize上限时报OOM）

<img src="images/172.png" alt="img" style="zoom:67%;" />

* 到了JDK8，终于完全废弃了永久代的概念，改用与JRocket、J9一样在本地内存中实现的元空间（Metaspace）来代替

  <img src="images/173.png" alt="img" style="zoom:67%;" />

* 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<font color=red>**元空间不在虚拟机设置的内存中，而是使用本地内存。**</font>

* 永久代、元空间二者并不只是名字变了，内部结构也调整了。

* 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。

### 3 设置方法区的大小与OOM

* 方法区的大小不必是固定的，JVM可以根据应用的需求动态调整。

* <font color=red>**JDK7及以前：**</font>

  * <font color=blue>**通过-XX:PermSize来设置永久费初始分配空间。默认值是20.75M**</font>

  * <font color=blue>**-XX:MaxPermSize来设定永久代最大可分配空间。32位机器默认64M，64位机器模式是82M**</font>

  * 当JVM加载的类信息容量超过了这个值，会报OutOfMemoryError:PermGenspace。

    <img src="images/174.png" alt="img" style="zoom:100%;" />

* <font color=red>**JDK8及以后：**</font>

  * 元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替代上述原有的两个参数。

  * 默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。

  * 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace

  * -XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。

  * 如果初始化的高水位线设置过低，上述高水位线调整情况会发生多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁GX，建议将-XX:MetaspaceSize设置为一个相对较高的值。

    <img src="images/175.png" alt="img" style="zoom:100%;" />

---

```java
/**
 * jdk6/7中：
 * -XX:PermSize=5m -XX:MaxPermSize=5m
 *
 * jdk8中：
 * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m
 */
public class OOMTest extends ClassLoader {
    public static void main(String[] args) {
        int j = 0;
        try {
            OOMTest test = new OOMTest();
            for (int i = 0; i < 10000; i++) {
                //创建ClassWriter对象，用于生成类的二进制字节码
                ClassWriter classWriter = new ClassWriter(0);
                //指明版本号，修饰符，类名，包名，父类，接口
                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, "Class" + i, null, "java/lang/Object", null);
                //返回byte[]
                byte[] code = classWriter.toByteArray();
                //类的加载
                test.defineClass("Class" + i, code, 0, code.length);//Class对象
                j++;
            }
        } finally {
            System.out.println(j);
        }
    }
}
```

**结果：**

<img src="images/176.png" alt="img" style="zoom:70%;" />

**更改JDK1.8为JDK1.7，V1_8改为V1_6，运行结果**

<img src="images/177.png" alt="img" style="zoom:70%;" />

---

* 如何解决这些OOM？
  1. 要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）。
  2. 如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾回收器无法自动回收它们的。掌握了泄露对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置。
  3. 如果不存在内存泄露，换句话说就是内存中的对象确实都还必须活着，那就应当检查虚拟机的堆参数（-Xms和-Xmx），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象声明周期过长、持有状态过长的情况，尝试减少程序运行期的内存消耗。

### 4 方法区的内部结构

<img src="images/178.png" alt="img" style="zoom:67%;" />

* 《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量（包含StringTable，即字符串常量池）、静态变量、即时编译器编译后的代码缓存等。

  <img src="images/179.png" alt="img" style="zoom:67%;" />

  * **类型信息**：对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区存储以下类型信息：

    ① 这个类型的完整有效名称（全名=包名.类名）

    ② 这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）

    ③ 这个类型的修饰符（public,abstract,final的某个子集）

    ④ 这个类型直接接口的一个有序列表

  * **域（Field）信息**

    * JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。
    * 域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient的某个子集）

  * **方法（Method）信息**：JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：

    * 方法名称
    * 方法的返回类型（或void）
    * 方法参数的数量和类型（按顺序）
    * 方法的修饰符（public、private、protected、static、final、synchronized、native、abstract的一个子集）
    * 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
    * 异常表（abstract和native方法除外）
      * 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

  * 代码演示

    ```java
    public class MethodInnerStrucTest extends Object implements Comparable<String>,Serializable {
        //属性
        public int num = 10;
        private static String str = "测试方法的内部结构";
        //构造器
        //方法
        public void test1(){
            int count = 20;
            System.out.println("count = " + count);
        }
        public static int test2(int cal){
            int result = 0;
            try {
                int value = 30;
                result = value / cal;
            } catch (Exception e) {
                e.printStackTrace();
            }
            return result;
        }
    
        @Override
        public int compareTo(String o) {
            return 0;
        }
    }
    ```

    通过  javap -v -p MethodInnerStrucTest.class > test.txt  将反编译的文件写入到test.txt文件中

    <img src="images/180.png" alt="img" style="zoom:80%;" />

    <img src="images/181.png" alt="img" style="zoom:80%;" />

    <img src="images/182.png" alt="img" style="zoom:70%;" />

---

* non-final的类变量

  * 静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。

  * 类变量被类的所有实例共享，即使没有类实例时你也可以访问它。

  * 代码演示

    ```java
    public class MethodAreaTest {
        public static void main(String[] args) {
            Order order = null;
            order.hello();
            System.out.println(order.count);
        }
    }
    
    class Order {
        public static int count = 1;
        public static final int number = 2;
        
        public static void hello() {
            System.out.println("hello!");
        }
    }
    ```

    **结果：**

    ​			hello!

    ​			1

  * 补充说明：全局常量：static final

    * 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了

    * 通过Order.class反编译得到的结果可以看出count和number的区别

      <img src="images/183.png" alt="img" style="zoom:70%;" />

---

* 运行时常量池 *vs* 常量池

  <img src="images/184.png" alt="img" style="zoom:67%;" />

  * 方法区，内部包含了运行时常量池。
  * 字节码文件，内部包含了常量池，将该常量池加载到方法区后就成了运行时常量池
  * 要弄清楚方法区，需要理解清除ClassFIle，因为加载类的信息都在方法区。
  * 要弄清楚方法区的运行时常量池，需要理解清楚ClassFIle中的常量池。
  * https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html

  <img src="images/185.png" alt="img" style="zoom:90%;" />

  ---

  <img src="images/186.png" alt="img" style="zoom:80%;" />

  一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息，还包含一项信息就是常量池表（COnstant Pool Table），包含各种字面量和对类型、域和方法的方法引用。

* 为什么需要常量池？

  * 一个java原文件的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据很大以至于不能直接存到字节码中，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。动态链接的时候会用到运行时常量池，之前有介绍。比如：如下的代码：

    ```java
    public class SimpleClass {
        public void sayHello() {
            System.out.println("hello");
        }
    }
    ```

    class文件虽然只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里代码量其实已经很小。如果代码多，引用的结构会更多！这里就需要常量池了！

* 常量池中有什么？

  * 几种在常量池内存储的类型包括：
    * 数量值
    * 字符串值
    * 类引用（含有接口）
    * 字段引用
    * 方法引用

* 小节：常量池，可以看做一张表，虚拟机志林根据这张表找到要执行的类名、方法名、参数类型、字面量等类型。

* 运行时常量池

  * 运行时常量池（Runtime Constant Pool）是方法区的一部分。
  * 常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译（前端编译）期间生成的各种字面量和符号引用，<font color=red>**这部分内容将在类加载后存放到方法区的运行时常量池中**</font>。
  * 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
  * JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。
  * 运行时常量池中包含多种不同的常量，包括编译期间（前端编译）就已经明确的数字字面量，也包括到到运行期解析后才能获得的方法或者字段引用。此时不再是常量池中的符号引用了，这里换为了真实地址。
    * 运行时常量池，相对于Class文件常量池的另一个重要特征时：<font color=red>**具备动态性**</font>。
      * String.intern()
  * 运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。
  * 当创建类或接口的运行时常量池时，如果构造运行时常量池所需要的内存空间超过了方法区所能提供的最大值，则JVM会抛出OutOfMemoryError异常。

### 5 方法区使用举例

```java
public class MethodAreaDemo {
    public static void main(String[] args) {
        int x = 500;
        int y = 100;
        int a = x / y;
        int b = 50;
        System.out.println(a + b);
    }
}
```

<img src="images/187.png" alt="img" style="zoom:67%;" />

<img src="images/188.png" alt="img" style="zoom:67%;" />

<img src="images/189.png" alt="img" style="zoom:67%;" />

<img src="images/190.png" alt="img" style="zoom:67%;" />

<img src="images/191.png" alt="img" style="zoom:67%;" />

<img src="images/192.png" alt="img" style="zoom:67%;" />

<img src="images/193.png" alt="img" style="zoom:67%;" />

<img src="images/194.png" alt="img" style="zoom:67%;" />

<img src="images/195.png" alt="img" style="zoom:67%;" />

<img src="images/196.png" alt="img" style="zoom:67%;" />

<img src="images/197.png" alt="img" style="zoom:67%;" />

<img src="images/198.png" alt="img" style="zoom:67%;" />

<img src="images/199.png" alt="img" style="zoom:67%;" />

<img src="images/200.png" alt="img" style="zoom:67%;" />

<img src="images/201.png" alt="img" style="zoom:67%;" />

<img src="images/202.png" alt="img" style="zoom:67%;" />

### 6 方法区的演进细节

1. 首先明确：只有HotSpot才有永久代。BEA JRocket、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。

2. Hotspot中方法区的变化：

   | jdk1.6及以前 | <font color=red>**有永久代（permanent generation），静态变量存放在永久代上**</font> |
   | :----------- | ------------------------------------------------------------ |
   | jdk1.7       | <font color=red>**有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中**</font> |
   | jdk1.8及以后 | <font color=red>**无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中**</font> |

---

* jdk1.6

  <img src="images/203.png" alt="img" style="zoom:67%;" />

* jdk1.7：方法区仍然使用虚拟机的内存

  <img src="images/204.png" alt="img" style="zoom:67%;" />

* jdk1.8

  <img src="images/205.png" alt="img" style="zoom:67%;" />

---

* 永久代为什么要被元空间替换？

  * http://openjdk.java.net/jeps/122

    <img src="images/206.png" alt="img" style="zoom:90%;" />

  * 随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据也消失了。这些数据被移动到一个与堆不相连的内存本地区域，这个区域叫做元空间（Metaspace）。

  * 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。

  * 这项改动是由必要的，原因有：

    1）<font color=blue>**为永久代设置空间大小是很难确定的**</font>。

    在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断加载很多类，经常出现致命错误。

    而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。

    2）<font color=blue>**对永久代调优是很困难的**</font>。

---

* StringTable（字符串常量池）为什么要调整位置（从方法区移到堆中）？
  * jdk7中将StringTable放到堆空间中。因为永久代的回收效率很低，在full gc的时候才会被处罚。而full gc是老年代空间不足或者永久代不足时才会触发。这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆中，能及时回收内存。

---

* 静态变量

  ```java
  /**
   * 结论：
   * 静态引用对应的对象实体始终都存在堆空间
   *
   * jdk7：
   * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails
   * jdk 8：
   * -Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails
   */
  public class StaticFieldTest {
      private static byte[] arr = new byte[1024 * 1024 * 100];//100MB
  
      public static void main(String[] args) {
          System.out.println(StaticFieldTest.arr);
      }
  }
  ```

  * 如何证明静态变量在堆中：需要使用jdk9中引入的工具jhsdb

    ```java
    /**
     * 《深入理解Java虚拟机》中的案例：
     * staticObj、instanceObj、localObj存放在哪里？
     */
    public class StaticObjTest {
        static class Test {
            static ObjectHolder staticObj = new ObjectHolder();
            ObjectHolder instanceObj = new ObjectHolder();
    
            void foo() {
                ObjectHolder localObj = new ObjectHolder();
                System.out.println("done");
            }
        }
    
        private static class ObjectHolder {
        }
    
        public static void main(String[] args) {
            Test test = new StaticObjTest.Test();
            test.foo();
        }
    }
    ```

    <img src="images/207.png" alt="img" style="zoom:67%;" />

    <img src="images/208.png" alt="img" style="zoom:67%;" />

### 7 方法区的垃圾回收

<img src="images/209.png" alt="img" style="zoom:67%;" />

<img src="images/210.png" alt="img" style="zoom:67%;" />

<img src="images/211.png" alt="img" style="zoom:67%;" />

### 8 总结

<img src="images/212.png" alt="img" style="zoom:67%;" />

* 常见面试题
  * <font color=red>**百度**</font>
    * 三面：说一下JVM内存模型吧，有哪些区？分别是干什么的？
  * <font color=red>**蚂蚁金服**</font>
    * Java8内存分代改进
    * JVM内存分为哪几个区，每个区的作用是什么？
    * 一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么需要连个survivor区？
    * 二面：Eden和Survivor的比例分配
  * <font color=red>**小米**</font>
    * jvm内存分区，为什么要有新生代和老年代？
  * <font color=red>**字节跳动**</font>
    * 二面：Java的内存分区
    * 二面：讲讲jvm运行时数据库区
    * 什么时候对象会进入老年代？
  * <font color=red>**京东**</font>
    * JVM的内存结构，Eden和Survivor比例。
    * JVM内存为什么要分为新生代、老年代、持久代？新生代为什么要分为Eden和Survivor？
  * <font color=red>**天猫**</font>
    * 一面：JVM内存模型及分区，需要详细到每个区放什么。
    * 一面：JVM内存模型，Java8做了什么修改
  * <font color=red>**拼多多**</font>
    * JVM内存分为哪几个区，每个区的作用是什么？
  * <font color=red>**美团**</font>
    * java内存分配
    * jvm的永久代会发生垃圾回收吗？
    * 一面：jvm内存分区，为什么需要新生代和老年代？

## 第10章 对象的实例化内存布局与访问定位

### 1 对象的实例化

* 面试题
  * <font color=red>**美团**</font>
    * 对象在JVM中是怎么存储的？
    * 对象头信息里面有哪些东西？
  * <font color=red>**蚂蚁金服**</font>
    * 二面：java对象头里有什么？

---

<img src="images/213.png" alt="img" style="zoom:80%;" />

<img src="images/214.png" alt="img" style="zoom:80%;" />

---

* 创建对象的步骤

  1. <font color=red>**判断对象对应的类是否加载、链接、初始化**</font>

     虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名 为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Classs对象

  2. <font color=red>**为对象分配内存**</font>

     首先计算对象占用空间大小，接着再堆中分配一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。

     * 如果内存规整，使用**指针碰撞**

       如果内存是规整的，那么虚拟机将采用指针碰撞法（Bump The Pointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于标记-压缩算法的，虚拟机采用这种分配方式。一般使用带有compact（整理）过程的收集器时，使用指针碰撞。

     * 如果内存不规整，虚拟机需要维护一个列表，使用**空闲列表**分配

       如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为“空闲列表（Free List）”。

       <font color=blue>**说明**</font>：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾回收器是否带有压缩整理功能决定。

  3. <font color=red>**处理并发安全问题**</font>

     在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发安全问题。虚拟机采用了两种方式解决并发安全问题：

     * CAS（Compare And Swap）失败重试、区域加锁：保证指针更新操作的原子性；
     * TLAB吧内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为**本地线程分配缓冲区**（TLAB，Thread Local Allocation Buffer），虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。

  4. <font color=red>**初始化分配到的空间**</font>

     内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。

  5. <font color=red>**设置对象的对象头**</font>

     将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。

  6. <font color=red>**执行init方法进行初始化**</font>

     在Java程序的视角来看，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。

     因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，吧对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。

### 2 对象的内存布局

* 创建的对象在堆中的含有哪些内容

  <img src="images/215.png" alt="img" style="zoom:80%;" />

  并不是所有的对象都会保存类型指针

* 例子

  ```java
  /**
   * 测试对象实例化的过程
   *  ① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）
   *  - ⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化
   *
   *
   *  给对象的属性赋值的操作：
   *  ① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化
   */
  
  public class Customer{
      int id = 1001;  // ② 显式初始化
      String name;
      Account acct;
  
      {
          name = "匿名客户";  // ③ 代码块中初始化
      }
      public Customer(){
          acct = new Account();  // ④ 构造器中初始化
      }
  
  }
  class Account{
  
  }
  ```

  ```java
  public class CustomerTest {
      public static void main(String[] args) {
          Customer cust = new Customer();
      }
  }
  ```

  <img src="images/216.png" alt="img" style="zoom:80%;" />

### 3 对象的访问定位

<img src="images/217.png" alt="img" style="zoom:80%;" />

* JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢？

  * 通过栈上reference访问

  <img src="images/218.png" alt="img" style="zoom:67%;" />

* 对象访问的两种方式

  * 句柄访问

    <img src="images/219.png" alt="img" style="zoom:67%;" />

    * 优点：GC之后只需要改变句柄池中的地址即可
    * 缺点：访问效率低，访问实例数据和元数据均需要中转一次

  * 直接指针（Hotspot采用）

    <img src="images/220.png" alt="img" style="zoom:67%;" />

    优点：访问效率高，访问实例数据一步到位

    缺点：GC之后需要更改虚拟机栈中本地变量表中的引用地址

## 第11章 直接内存（Direct Memory）

* 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。

* 直接内存是在Java堆外的、直接向系统申请的内存空间。

* 来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存。

  ```java
  /**
   *  IO                  NIO (New IO / Non-Blocking IO)
   *  byte[] / char[]     Buffer
   *  Stream              Channel
   *
   * 查看直接内存的占用与释放
   */
  public class BufferTest {
      private static final int BUFFER = 1024 * 1024 * 1024;//1GB
  
      public static void main(String[] args){
          // 直接分配本地内存空间
          ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);
          System.out.println("直接内存分配完毕，请求指示！");
  
          Scanner scanner = new Scanner(System.in);
          scanner.next();
  
          System.out.println("直接内存开始释放！");
          byteBuffer = null;
          System.gc();
          scanner.next();
      }
  }
  ```

  <img src="images/221.png" alt="img" style="zoom:100%;" />

* 通常，访问直接内存的速度会优于Java堆。即读写性能高。

  * 因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。
  * Java的NIO库允许Java程序使用直接内存，用于数据缓存区

  <img src="images/222.png" alt="img" style="zoom:70%;" />

  <img src="images/223.png" alt="img" style="zoom:70%;" />

---

* 也可能导致OutOfMemoryError异常

* 由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是优先的，Java堆和直接内存的总和依然受限于操作系统能给的最大内存。

  ```java
  /**
   * 本地内存的OOM:  OutOfMemoryError: Direct buffer memory
   */
  public class BufferTest2 {
      private static final int BUFFER = 1024 * 1024 * 20;//20MB
  
      public static void main(String[] args) {
          ArrayList<ByteBuffer> list = new ArrayList<>();
  
          int count = 0;
          try {
              while(true){
                  ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);
                  list.add(byteBuffer);
                  count++;
                  try {
                      Thread.sleep(100);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }
          } finally {
              System.out.println(count);
          }
      }
  }
  ```

  <img src="images/224.png" alt="img" style="zoom:90%;" />

* 缺点

  * 分配回收成本高
  * 不受JVM内存回收管理

* 直接内存大小可以通过MaxDirectMemorySize设置

  ```java
  /**
   * 绕过DirectByteBuffer，直接分配本地内存
   * -Xmx20m -XX:MaxDirectMemorySize=10m
   *
   * @author shkstart  shkstart@126.com
   * @create 2020  0:36
   */
  public class MaxDirectMemorySizeTest {
      private static final long _1MB = 1024 * 1024;
  
      public static void main(String[] args) throws IllegalAccessException {
          Field unsafeField = Unsafe.class.getDeclaredFields()[0];
          unsafeField.setAccessible(true);
          Unsafe unsafe = (Unsafe) unsafeField.get(null);
          while (true) {
              unsafe.allocateMemory(_1MB);
          }
      }
  }
  ```

  <img src="images/225.png" alt="img" style="zoom:90%;" />

* 如果不指定，默认与堆的最大值-Xmx参数值一致

---

<img src="images/226.png" alt="img" style="zoom:90%;" />

简单理解：<font color=red>**java process memory = java heap + native memory**</font>

## 第12章 执行引擎

### 1 执行引擎概述

<img src="images/227.png" alt="img" style="zoom:67%;" />

* 执行引擎是Java虚拟机核心的组成部分之一。
* “虚拟机”是相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<font color=red>**虚拟机的执行引擎则是由软件自行实现的**</font>，因此可以不受物理条件限制地定制指令集和执行引擎的体系结构，<font color=red>**能够执行那些不被硬件直接支持的指令集格式**</font>。

---

* JVM的主要任务是负责<font color=red>**装载字节码到其内部**</font>，但字节码并不能直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。
* 那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<font color=red>**将字节码指令解释/编译为对应平台上的本地机器指令才可以**</font>。简单来说，JVM的执行引擎充当了将高级语言翻译为机器语言的译者。

---

<img src="images/228.png" alt="img" style="zoom:67%;" />

* 外观上来看，所有的Java虚拟机的执行引擎、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。

### 2 Java代码编译和执行过程

<img src="images/229.png" alt="img" style="zoom:67%;" />

* 大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图的各个步骤。

---

* Java代码编译是由Java源码编译器来完成，流程图如下所示（javac，前端编译）：

  <img src="images/230.png" alt="img" style="zoom:67%;" />

* Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：

  <img src="images/231.png" alt="img" style="zoom:67%;" />

---

* **问题：什么是解释器（Interpreter），什么是JIT编译器？**
  * 解释器：当Java虚拟机启动时会根据预定义的规范<font color=blue>**对字节码采用逐行解释的方式执行**</font>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。
  * JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译（后端编译）成和本地机器相关的机器语言。
* **问题：为什么说Java是半编译半解释型语言？**
  * JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展处可以直接生成本地代码的编译器。
  * 现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行两者结合起来进行。

### 3 机器码、指令、汇编语言

<img src="images/232.png" alt="img" style="zoom:67%;" />

---

* 机器码
  * 各种用二进制编码方式表示的指令，叫做<font color=blue>**机器指令码**</font>。开始，人们就用它编写程序，这就是机器语言。
  * 机器语言虽然能够被计算机理解和接收，但和人们的语言差别太大，不容易被人们理解和记忆，并且用它编程容易出差错。
  * 用它编写的程序已经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。
  * 机器指令与CPU密切相关，所以不同种类的CPU锁对应的机器指令也就不同。
* 指令
  * 由于机器码是由0和1组成的二进制序列，可读性是在太差，于是人们发明了指令。
  * 指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好。
  * 由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。
* 指令集
  * 不同的硬件平台，各自支持的指令，是由差别的。因此每个平台所支持的指令，称之为对应平台的指令集。
  * 如常见的
    * x86指令集，对应的是x86架构的平台
    * ARM指令集，对应的是ARM架构的平台

---

* 汇编语言
  * 由于指令的可读性还是太差，于是人们又发明了汇编语言。
  * 在汇编语言中，用<font color=blue>**助记符**</font>（Mnemonics）代替<font color=blue>**机器指令的操作码**</font>，用<font color=blue>**地址符号（Symbol）或标号（Label）**</font>代替<font color=blue>**指令或操作数的地址**</font>。
  * 在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。
    * 由于计算机只认识指令码，所以用<font color=blue>**汇编语言编写的程序还必须翻译成机器指令码**</font>，计算机才能识别和执行。

---

* 高级语言
  * 为了使计算机用户编程更容易些，后来就出现了各种高级语言，高级语言比机器语言、汇编语言<font color=blue>**更接近人的语言**</font>。
  * 当计算机执行高级语言编写的程序时，<font color=blue>**仍然需要把程序解释和编译成机器的指令码**</font>。完成这个过程的程序就叫做解释程序或编译程序。

---

<img src="images/233.png" alt="img" style="zoom:67%;" />

---

* 字节码
  * 字节码是一种<font color=blue>**中间状态（中间码）的二进制代码（文件）**</font>，它比机器码更抽象，需要直译器转译才能成为机器码
  * 字节码主要为了实现特定软件运行和软件环境、<font color=blue>**与硬件环境无关**</font>。
  * 字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机将字节码转译为可以直接执行的指令。
    * 字节码的典型应用为Java bytecode。

---

<img src="images/234.png" alt="img" style="zoom:67%;" />

### 4 解释器

<img src="images/235.png" alt="img" style="zoom:67%;" />

* 为什么需要字节码文件？
  * 其实不需要字节码文件也可以实现跨平台，可以直接将Java源文件翻译成机器指令，但是这样对人的要求太高了，将任务分离，可以更好地分配任务。

---

* 解释器工作机制（或工作任务）

  * 解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。
  * 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。

* 解释器分类：在Java的发展历史里，一共有两套执行解释器，即古老的<font color=red>**字节码解释器**</font>、现在普遍使用的<font color=red>**模板解释器**</font>。

  * 字节码解释器在执行时通过<font color=blue>**纯软件代码**</font>模拟字节码的执行，效率非常低下。
  * 而模板解释器将<font color=blue>**每一条字节码和一个模板函数相关联**</font>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。
    * 在Hotspot VM中，解释器主要由Interpreter模块和Code模块构成。
      * Interpreter模块：实现了解释器的核心功能
      * Code模块：用于管理Hotspot VM在运行时生成的本地机器指令

* 看一下GitHub：cpython

  <img src="images/236.png" alt="img" style="zoom:67%;" />

  <img src="images/237.png" alt="img" style="zoom:67%;" />

---

* 现状
  * 由于解释器在设计和实现上非常简单，因此除了Java之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，<font color=blue>**基于解释器执行已经沦落为抵消的代名词**</font>，并且时常被一些C/C++程序员所调侃。
  * 为了解决这个问题，JVM平台支持一种叫做即时编译器的的技术。即时编译的目的是避免函数被解释执行，而是<font color=blue>**将整个函数体编译成机器码，每次函数执行时，只执行编译后的机器码即可**</font>，这种方式可以使执行效率大幅度提升。
  * 不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。

### 5 JIT编译器

* Java代码的执行分类
  * 第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行
  * 第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高效率，会使用即时编译技术（JIT，Just In Time）将发放编译成机器码后再执行。
* Hotspot VM是目前市面上高性能虚拟机的代表作之一。它<font color=blue>**采用解释器与即时编译器并存的架构**</font>。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。
* 在今天，Java程序的运行程序早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。

---

* 问题来了！

  * 有些开发人员会感觉到差异，<font color=blue>**既然Hotspot VM已经内置了JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？**</font>比如JRocket vm内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。

  * 首先明确：当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。所以：

    尽管JRocket VM中程序的执行性能会非常高，但程序在启动时必然需要花费更多的时间来进行编译。对于服务端来说，启动时间并非是关注点，但对于那些看重启动时间的场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<font color=red>**当Java虚拟机启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的diam编译成本地代码，获得更高的执行效率**</font>。

    同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。

---

* Hotspot JVM的执行方式
  * 当虚拟机启动的时候，<font color=blue>**解释器可以首先发挥作用**</font>，而不必等待即时编译器全部编译完成再执行，<font color=blue>**这样可以省去许多不必要的编译时间**</font>。并且随着程序运行时间的推移，即使编译器逐渐发挥作用，根据热点探测功能，<font color=blue>**将有价值的字节码编译为本地机器指令**</font>，以换取更高的程序执行效率。

<img src="images/238.png" alt="img" style="zoom:67%;" />

---

* 运行java程序后查看JIT编译次数和时间：jvisualvm或者jconsole

  ```java
  public class JITTest {
      public static void main(String[] args) {
          ArrayList<String> list = new ArrayList<>();
  
          for (int i = 0; i < 1000; i++) {
              list.add("让天下没有难学的技术");
              try {
                  Thread.sleep(1000);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
  
      }
  }
  ```

  <img src="images/239.png" alt="img" style="zoom:90%;" />

  <img src="images/240.png" alt="img" style="zoom:90%;" />

---

* JIT编译器
  * 概念解释
    * Java语言的“编译器”其实是一段“不确定”的操作过程，因为它可能是指一个<font color=blue>**前端编译器**</font>（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的付哦成；
    * 也肯能是指虚拟机的<font color=blue>**后端编译器**</font>（JIT编译器，Just In Time Compiler）吧字节码转变为机器码的过程。
    * 还可能是指使用<font color=blue>**静态提前编译器**</font>（AOT编译器，Ahead Of Time Compiler）直接把.java文件编译成本地机器代码的过程。
  * 各种编译器的代表
    * 前端编译器：Sun的Javax、Eclipse JDT中的增量式编译器（ECJ）。
    * JIT编译器：Hotspot VM的C1、C2编译器。
    * AOT编译器：GNU cOMPILER FOR THE jAVA（GCJ）、Excelsior JET。

---

* 如何选择解释器和即时编译器？
  * **采用热点代码及探测方式**
    * 当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用的<font color=red>**执行频率**</font>而定。关于那些需要被编译为本地代码的字节码，也被称之为<font color=red>**“热点代码”**</font>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<font color=red>**深度优化**</font>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。
    * <font color=blue>**。一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”**</font>，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为<font color=red>**OSR（On Stack Replacement）编译**</font>。
    * 一个方法究竟<font color=blue>**要被调用多少次**</font>，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<font color=red>**热点探测功能**</font>。
    * <font color=red>**目前Hotspot VM 所采用的热点探测技术是基于计数器的热点探测**</font>。
    * 采用基于计数器的热点探测，Hotspot VM将会为每个方法都建立2个不同类型的计数器，分别是方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。
      * 方法调用计数器用于统计方法的调用次数
      * 回边计数器则用于统计循环体执行的循环次数

---

* 方法调用计数器

  * 这个计数器用于统计方法调用的次数，他的默认阈值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。
  * 这个阈值可以通过虚拟机参数<font color=blue>**-XX:CompilerThreshold**</font>来人为设定。
  * 当一个方法被调用时，先会检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将次方法的调用计数器值加1，然后判断**方法调用计数器与回边计数器之和**是否超过方法调用计数器的阈值，如果超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。

  <img src="images/241.png" alt="img" style="zoom:67%;" />

* 热度衰减

  * 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<font color=blue>**一段时间之内被调用的次数**</font>。当超过<font color=red>**一定的时间限度**</font>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那么这个方法的调用计数器就会<font color=red>**减少一半**</font>，这个过程称为方法调用计数器热度的<font color=red>**衰减（Counter Decay）**</font>，而这段时间就成为次方法统计的<font color=red>**半衰周期（COunter Half Life Time）**</font>。

  * 进行热度衰减的动作实在虚拟机进行垃圾回收时顺便进行的，可以使用虚拟机参数<font color=blue>**-XX:-UseCounterDecay**</font>来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。

  * 另外，可以使用<font color=blue>**-XX:CounterHalfLifeTime**</font>设置半衰期的时间，单位是秒。

    <img src="images/242.png" alt="img" style="zoom:100%;" />

---

* 回边计数器

  * 它的作用是统计一个方法中**循环体代码执行的次数**，在字节码中雨大控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。

    <img src="images/243.png" alt="img" style="zoom:67%;" />

---

* Hotspot VM可以设置程序执行方式

  * 缺省情况下Hotspot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是<font color=blue>**完全采用解释器**</font>执行，还是<font color=blue>**完全采用即时编译器**</font>执行。如下所示：

    * <font color=blue>**-Xint**</font>：完全采用解释器模式执行程序
    * <font color=blue>**-Xcomp**</font>：完全采用即时编译器执行程序。如果即时编译器出现问题，解释器会介入执行。
    * <font color=blue>**-Xmixed**</font>：采用解释器+即时编译器的混合模式共同执行程序。

    <img src="images/244.png" alt="img" style="zoom:100%;" />

  * 代码演示：

    ```java
    /**
     * 测试解释器模式和JIT编译模式
     *  -Xint  : 6520ms
     *  -Xcomp : 950ms
     *  -Xmixed : 936ms
     */
    public class IntCompTest {
        public static void main(String[] args) {
    
            long start = System.currentTimeMillis();
    
            testPrimeNumber(1000000);
    
            long end = System.currentTimeMillis();
    
            System.out.println("花费的时间为：" + (end - start));
    
        }
    
        public static void testPrimeNumber(int count){
            for (int i = 0; i < count; i++) {
                //计算100以内的质数
                label:for(int j = 2;j <= 100;j++){
                    for(int k = 2;k <= Math.sqrt(j);k++){
                        if(j % k == 0){
                            continue label;
                        }
                    }
                    //System.out.println(j);
                }
            }
        }
    }
    ```

---

* 在Hotspot VM中内嵌有两个JIT编译器，分别是Client Compiler和Server Compiler，但大多数情况下我们简称C1编译器和C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即使编译器，如下所示：

  * <font color=blue>**-client**</font>：指定Java虚拟机运行在Client模式下，并且使用C1编译器；

    * C1编译器会对字节码进行<font color=red>**简单和可靠的优化，耗时短**</font>。以达到更快的编译速度。

  * <font color=blue>**-server**</font>：指定Java虚拟机运行在Server模式下，并且使用C2编译器（用C++编写的）；

    * C2进行<font color=red>**耗时较长的优化，以及激进优化**</font>。但优化的代码执行效率更高。

    对于64bit的机器我们不能指定为client模式，即使指定也不起作用，仍然是server模式的。

* C1和C2编译器不同的优化策略：

  * 在不同的编译器上有不同的优化策略，C1编译器上主要有**方法内联，去虚拟化、冗余消除**
    * <font color=blue>**方法内联**</font>：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程
    * <font color=blue>**去冗余化**</font>：对唯一的实现类进行内联
    * <font color=blue>**冗余消除**</font>：在运行期间把一些不会执行的代码折叠掉
  * C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：
    * <font color=blue>**标量替换**</font>：用标量值代替聚合对象的属性值
    * <font color=blue>**栈上分配**</font>：对于未逃逸的对象分配对象在栈而不是堆
    * <font color=blue>**同步消除**</font>：清除同步操作，通常指synchronized

* 分层编译（Tiered Compilation）策略

  * 程序解释执行（不开启性能监控）可以出发C1编译，将字节码编译成机器码，可以进行简单优化，C2编译会根据性能监控信息进行激进优化。
  * 不过在Java7版本之后，一旦开发人员在程序中显示指定命令"-server"时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同执行编译任务。

---

* 总结
  * 一般来讲，JIT编译出来的机器码性能比解释器高。
  * C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。

---

* 写在最后1：

  * 自JDK10起，Hotspot又加入一个全新的即时编译器：Graal编译器（和C1、C2是并列的概念）。

  * Graal编译器编译效果短短几年就最平了C2编译器，未来可期。

  * 目前，Graal编译器带着“实验状态”标签，需要使用开关参数

    <font color=blue>**-XX:+UnlockExperimentalVMOptions  -XX:+UseJVMCICompiler**</font>去激活，才能使用

* 写在最后2：关于AOT编译器（和JIT编译器是并列的概念）

  * JDK9引入了AOT编译器（静态提前编译器，Ahead Of Time Compiler）
  * Java9引入了实验性AOT编译工具jaotc。它借助Graal编译器，将所输入的Java类文件转为机器码，并且存放至生成的动态共享库之中。.java--->.class--->.so，其中.class--->.so是由jaotc完成的。
  * 所谓AOT编译，是与即时编译向对立的一个概念。我们知道，即时编译指的是在<font color=blue>**程序的运行过程中**</font>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中。而AOT编译指的是在<font color=blue>**程序运行之前**</font>，便将字节码转换为机器码的过程。
  * 最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。
  * 缺点
    * 破坏了java“一次编译，导出运行”，必须为每个不同硬件、OS编译对应的发型包。
    * <font color=blue>**降低Java连接过程的动态性**</font>，加载的代码在编译期就必须全部已知。
    * 还需要继续优化，最初只支持Linux x64 java base

##  第13章 StringTable

### 1 String的基本特性

* String：字符串，使用一对""引起来表示。

  * String s1 = "Hello";  // 字面量定义方式
  * String s2 = new String("Hello");

* String声明为final的，不可被继承

* String实现了Serializable接口：表示字符串是支持序列化的。

  ​		   实现了Comparable接口：表示String可以比较大小

* String在JDK8及以前内部定义了final char[] value用于储存字符串数据。JDK9时改为byte[]

---

* String在jdk9中存储结构变更

  * http://openjdk.java.net/jeps/254

    <img src="images/245.png" alt="img" style="zoom:80%;" />

  * 结论：String再也不用char[]来存储了，改成了byte[]加上编码标识，节约了一些空间。

    ```java
    public final class String
        implements java.io.Serializable, Comparable<String>, CharSequence {
        // ...
        @Stable
        private final byte[] value;
        
        // ...
    }
    ```

  * 那StringBuffer和StringBuilder是否仍无动于衷呢？

    * 修改了
    * String-related classes such as `AbstractStringBuilder`, `StringBuilder`, and `StringBuffer` will be updated to <font color=red>**use the same representation**</font>, as will the HotSpot VM's intrinsic（固有的、内置的） string operations.

---

* String：代表不可变的字符序列。简称：不可变性。

  * 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。
  * 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
  * 当调用String的replace()方法修改指定字符或字符串时，需要重新指定内存区域赋值，不能使用原有的value赋值。

* 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值生命在常量池中。

* 代码演示

  ```java
  /**
   * String的基本使用:体现String的不可变性
   */
  public class StringTest1 {
      @Test
      public void test1() {
          String s1 = "abc";  // 字面量定义的方式，"abc"存储在字符串常量池中
          String s2 = "abc";
          s1 = "hello";
  
          System.out.println(s1 == s2);  // 判断地址：true  --> false
          System.out.println(s1);  // hello
          System.out.println(s2);  // abc
      }
  
      @Test
      public void test2() {
          String s1 = "abc";
          String s2 = "abc";
          s2 += "def";
          System.out.println(s1 == s2);
          System.out.println(s2);  // abcdef
          System.out.println(s1);  // abc
      }
  
      @Test
      public void test3() {
          String s1 = "abc";
          String s2 = s1.replace('a', 'm');
          System.out.println(s1 == s2);
          System.out.println(s1);  // abc
          System.out.println(s2);  // mbc
      }
  }
  ```

---

* 一道面试题

  ```java
  public class StringExer {
      String str = new String("good");
      char[] ch = {'t', 'e', 's', 't'};
  
      public void change(String str, char ch[]) {
  //        this.str = "test ok";
          str = "test ok";
          ch[0] = 'b';
      }
  
      public static void main(String[] args) {
          StringExer ex = new StringExer();
          ex.change(ex.str, ex.ch);
          System.out.println(ex.str);  // good
          System.out.println(ex.ch);  // best
      }
  }
  ```

---

* <font color=red>**字符串常量池中是不会存储相同的内容的字符串的**</font>。

  * String是String Pool（字符串常量池）是一个固定大小的Hashtable，默认值大小长度时1009.如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了以后直接会造成的影响就是当调用String.intern时性能大幅下降。

  * 使用<font color=blue>**-XX:StringTableSize**</font>可以设置StringTable的长度

  * 在jdk6中StringTable是固定的，就是1009的长度，所以常量池中的字符串过多就会导致效率下降很快。StringTableSize设置没有要求

  * 在jdk7中，StringTable的默认长度时60013，StringTableSize设置没有要求

  * jdk8开始，设置StringTable的长度的话，1009是可以设置的最小值。

    <img src="images/246.png" alt="img" style="zoom:100%;" />

    <img src="images/247.png" alt="img" style="zoom:100%;" />

  * 设置不同的StringTableSize的性能对比

    ```java
    public class StringTest2 {
        public static void main(String[] args) {
            BufferedReader br = null;
            try {
                // word.txt是含有10万行，每行长度1~10的txt文件
                br = new BufferedReader(new FileReader("words.txt"));
                long start = System.currentTimeMillis();
                String data;
                while((data = br.readLine()) != null){
                    data.intern();   // 如果字符串常量池中没有对应data的字符串的话，则在常量池中生成
                }
                long end = System.currentTimeMillis();
                System.out.println("花费的时间为：" + (end - start));  // 1009:253ms  100009:52ms
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                if(br != null){
                    try {
                        br.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    ```

### 2 String的内存分配

* 在Java语言中有8中基本数据类型和一种比较特殊的类型String。这些类型为了使他们再运行过程中更快、更节省内存，都提供了一种常量池的概念。
* 常量池就类似于一个Java级别提供的缓存。8中基本数据类型的常量池都是系统协调的，<font color=red>**String类型的常量池比较特殊。它的主要使用方法有两种**</font>。
  * 直接使用双引号声明出来的String对象会直接存储在字符串常量池中。
    * 比如： String info = "Hello";
  * 如果不是用双引号声明的String对象，可以使用String提供的intern()方法。这个后面重点谈。

---

* Java 6及以前，字符创常量池存放在永久代。

  <img src="images/203.png" alt="img" style="zoom:67%;" />

* Java 7中Oracle的工程师对字符串常量池的逻辑做了很大的改变，即将<font color=red>**字符串常量池的位置调整到Java堆中**</font>。

  * 所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。

  * 字符串常量池概念原本使用的比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。

    <img src="images/204.png" alt="img" style="zoom:67%;" />

* Java 8元空间，字符串常量在堆。

<img src="images/205.png" alt="img" style="zoom:67%;" />

---

* StringTable为什么要调整？

  ① permSize默认比较小

  ② 方法区垃圾回收频率比较低

  * 官网：https://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html#jdk7changes

    <img src="images/248.png" alt="img" style="zoom:100%;" />

* 代码演示OOM：

  ```java
  /**
   * jdk6中：
   * -XX:PermSize=6m -XX:MaxPermSize=6m -Xms6m -Xmx6m
   *
   * jdk8中：
   * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m -Xms10m -Xmx10m
   */
  public class StringTest3 {
      public static void main(String[] args) {
          // 使用Set保持着常量池引用，避免full gc回收常量池行为
          Set<String> set = new HashSet<String>();
          // 在short可以取值的范围内足以让6MB的PermSize或heap产生OOM了。
          int i = 0;
          while(true){
              set.add(String.valueOf(i++).intern());
          }
      }
  }
  ```

  <img src="images/249.png" alt="img" style="zoom:100%;" />

  <img src="images/250.png" alt="img" style="zoom:100%;" />

### 3 String的基本操作

```java
public class StringTest4 {
    public static void main(String[] args) {
        System.out.println();  // 常量池中字符串个数：2166
        System.out.println("1");  // 2167
        System.out.println("2");
        System.out.println("3");
        System.out.println("4");  // 2170
        //如下的字符串"1" 到 "4"不会再次加载
        System.out.println("1");  // 2171
        System.out.println("2");  // 2171
        System.out.println("3");
        System.out.println("4");  // 2171
    }
}
```

Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。

---

```java
class Memory {
    public static void main(String[] args) {  // line 1
        int i = 1;  // line 2
        Object obj = new Object();  // line 3
        Memory mem = new Memory();  // line 4
        mem.foo(obj);  // line 5
    }  // line 9

    private void foo(Object param) {  // line 6
        String str = param.toString();  // line 7
        System.out.println(str);
    }  // line 8
}
```

<img src="images/251.png" alt="img" style="zoom:67%;" />

### 4 字符串拼接操作

* 字符串拼接操作
  1. 常量与常量的拼接结果在常量池，原理是编译器优化
  2. 常量池中不会存在相同内容的变量。
  3. 只要其中一个是变量，结果就在堆（堆中的非字符串常量池的位置）中。变量拼接的原理是StringBuilder。
  4. 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入字符串常量池中，并返回次对象地址。

---

```java
/**
 * 字符串拼接操作
 *
 * @author shkstart  shkstart@126.com
 * @create 2020  0:59
 */
public class StringTest5 {
    @Test
    public void test1() {
        String s1 = "a" + "b" + "c";  // 编译（前端编译）期优化：等同于"abc"
        String s2 = "abc";  // "abc"一定是放在字符串常量池中，将此地址赋给s2
        /*
         * 最终.java编译成.class,再执行.class
         * String s1 = "abc";
         * String s2 = "abc"
         */
        System.out.println(s1 == s2);  // true
        System.out.println(s1.equals(s2));  // true
    }

    @Test
    public void test2() {
        String s1 = "javaEE";
        String s2 = "hadoop";

        String s3 = "javaEEhadoop";
        String s4 = "javaEE" + "hadoop";  // 编译期优化
        // 如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop
        String s5 = s1 + "hadoop";
        String s6 = "javaEE" + s2;
        String s7 = s1 + s2;

        System.out.println(s3 == s4);  // true
        System.out.println(s3 == s5);  // false
        System.out.println(s3 == s6);  // false
        System.out.println(s3 == s7);  // false
        System.out.println(s5 == s6);  // false
        System.out.println(s5 == s7);  // false
        System.out.println(s6 == s7);  // false
        // intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；
        // 如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。
        String s8 = s6.intern();
        System.out.println(s3 == s8);  // true
    }

    @Test
    public void test3() {
        String s1 = "a";
        String s2 = "b";
        String s3 = "ab";
        /*
        如下的s1 + s2 的执行细节：(变量s是我临时定义的）
        ① StringBuilder s = new StringBuilder();
        ② s.append("a")
        ③ s.append("b")
        ④ s.toString()  --> 约等于 new String("ab")

        补充：在jdk5.0及之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer
         */
        String s4 = s1 + s2;
        System.out.println(s3 == s4);  // false
    }

    /*
    1. 字符串拼接操作不一定使用的是StringBuilder!
       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。
    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。
     */
    @Test
    public void test4() {
        final String s1 = "a";
        final String s2 = "b";
        String s3 = "ab";
        String s4 = s1 + s2;
        System.out.println(s3 == s4);  // true
    }

    //练习：
    @Test
    public void test5() {
        String s1 = "javaEEhadoop";
        String s2 = "javaEE";
        String s3 = s2 + "hadoop";
        System.out.println(s1 == s3);  // false

        final String s4 = "javaEE";  // s4:常量
        String s5 = s4 + "hadoop";
        System.out.println(s1 == s5);  // true

    }

    /*
    体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！
    详情：① StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象
          使用String的字符串拼接方式：创建过多个StringBuilder和String的对象
         ② 使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。

     改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议使用构造器实例化：
               StringBuilder s = new StringBuilder(highLevel);  // new char[highLevel]
     */
    @Test
    public void test6() {

        long start = System.currentTimeMillis();

//        method1(100000);  // 4014
        method2(100000);  // 7

        long end = System.currentTimeMillis();

        System.out.println("花费的时间为：" + (end - start));
    }

    public void method1(int highLevel) {
        String src = "";
        for (int i = 0; i < highLevel; i++) {
            src = src + "a";  // 每次循环都会创建一个StringBuilder、String
        }
//        System.out.println(src);

    }

    public void method2(int highLevel) {
        // 只需要创建一个StringBuilder
        StringBuilder src = new StringBuilder();
        for (int i = 0; i < highLevel; i++) {
            src.append("a");
        }
//        System.out.println(src);
    }
}
```

* 对于test1，两种方式可以证明s1编译前已经被优化为"abc"

  * 通过查看编译后的字节码文件内容

    <img src="images/252.png" alt="img" style="zoom:100%;" />

  * 通过jclasslib查看字节码信息

    <img src="images/253.png" alt="img" style="zoom:100%;" />

* 对于test3()，我们可以通过jclasslib看到s4是如何被创建的

  <img src="images/254.png" alt="img" style="zoom:100%;" />

* 对于test4()，里面的量用final修饰，仍然使用编译期优化，相当于s4 = "a" + "b";

### 5 intern()使用

* intern()源码

  ```java
  public final class String
      implements java.io.Serializable, Comparable<String>, CharSequence {
  	// ...
      
      public native String intern();
  }
  ```

  <img src="images/255.png" alt="img" style="zoom:80%;" />

---

* 如果不是双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就将当前字符串放入常量池中。
  * 比如：String myInfo = new String("Hello").intern();
* 也就是说，如果在任意字符串上调用String.intern方法，那么返回结果所指向的那个类实例，必须和直接以常量形式的字符串实例完全相同。因此，下列边大师的值必定为true：
  * ("a" + "b" + "c").intern() == "abc"
* 通俗点将，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）。

---

* 关于new String创建对象的个数问题：根本是从字节码分析

  ```java
  /**
   * 题目：
   * new String("ab")会创建几个对象？看字节码，就知道是两个。
   *     一个对象是：new关键字在堆空间创建的
   *     另一个对象是：字符串常量池中的对象"ab"。 证明：字节码指令：ldc
   *
   *
   * 思考：
   * new String("a") + new String("b")呢？
   *  对象1：new StringBuilder()
   *  对象2： new String("a")
   *  对象3： 常量池中的"a"
   *  对象4： new String("b")
   *  对象5： 常量池中的"b"
   *
   *  深入剖析： StringBuilder的toString():
   *      对象6 ：new String("ab")
   *       强调一下，toString()的调用，在字符串常量池中，没有生成"ab"
   */
  public class StringNewTest {
      public static void main(String[] args) {
  //        String str = new String("ab");
  
          String str = new String("a") + new String("b");
      }
  }
  ```

---

* 一道难度极高的面试题：

  ```java
  public class StringIntern {
      public static void main(String[] args) {
  
          String s = new String("1");
          s.intern();  // 调用此方法之前，字符串常量池中已经存在了"1"
          String s2 = "1";
          System.out.println(s == s2);  // jdk6：false   jdk7/8：false
  
  
          String s3 = new String("1") + new String("1");  // s3变量记录的地址为：new String("11")
          // 执行完上一行代码以后，字符串常量池中，是否存在"11"呢？答案：不存在！！
          s3.intern();  // 在字符串常量池中生成"11"。如何理解：jdk6:创建了一个新的对象"11",也就有新的地址。
                                               //         jdk7:此时常量中并没有创建"11",而是创建一个指向堆空间中new String("11")的地址
          String s4 = "11";  // s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的"11"的地址
          System.out.println(s3 == s4); // jdk6：false  jdk7/8：true
      }
  }
  ```

  <img src="images/256.png" alt="img" style="zoom:67%;" />

  <img src="images/257.png" alt="img" style="zoom:67%;" />

* 上一题的变式

  ```java
  public class StringIntern1 {
      public static void main(String[] args) {
          // StringIntern.java中练习的拓展：
          String s3 = new String("1") + new String("1");  // new String("11")
          // 执行完上一行代码以后，字符串常量池中，是否存在"11"呢？答案：不存在！！
          String s4 = "11";  // 在字符串常量池中生成对象"11"
          String s5 = s3.intern();
          System.out.println(s3 == s4);  // false
          System.out.println(s5 == s4);  // true
      }
  }
  ```

* 总结String的intern()的使用：

  * jdk1.6中，将这个字符串尝试放入串池。
    * 如果串池中有，则并不会放入。返回已有的串池的对象的地址
    * 如果没有，会把<font color=blue>**此对象复制一份**</font>，放入串池，并返回串池中的对象地址
  * jdk1.7起，将这个字符串尝试放入串池
    * 如果串池中有，则并不会放入。返回已有的串池的对象的地址
    * 如果没有，则会把<font color=blue>**对象的引用地址复制一份**</font>，放入串池，并返回串池中的引用地址

---

* intern()的使用：练习1

  <img src="images/258.png" alt="img" style="zoom:67%;" />

  <img src="images/259.png" alt="img" style="zoom:67%;" />

  <img src="images/260.png" alt="img" style="zoom:67%;" />

* intern()的使用：练习2

  ```java
  public class StringExer2 {
      public static void main(String[] args) {
          String s1 = new String("ab");  // 执行完以后，会在字符串常量池中会生成"ab"
          s1.intern();
          String s2 = "ab";
          System.out.println(s1 == s2);  // jdk6/7/8：false
      }
  }
  ```

  ```java
  public class StringExer2 {
      public static void main(String[] args) {
          String s1 = new String("a") + new String("b");  // 执行完以后，不会在字符串常量池中会生成"ab"
          s1.intern();
          String s2 = "ab";
          System.out.println(s1 == s2);  // jdk6：false	jdk7/8：true
      }
  }
  ```

---

* intern()空间效率测试

  ```java
  /**
   * 使用intern()测试执行效率：空间使用上
   * <p>
   * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。
   *
   * @author shkstart  shkstart@126.com
   * @create 2020  21:17
   */
  public class StringIntern2 {
      static final int MAX_COUNT = 1000 * 10000;
      static final String[] arr = new String[MAX_COUNT];
  
      public static void main(String[] args) {
          Integer[] data = new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  
          long start = System.currentTimeMillis();
          for (int i = 0; i < MAX_COUNT; i++) {
  //            arr[i] = new String(String.valueOf(data[i % data.length]));
              arr[i] = new String(String.valueOf(data[i % data.length])).intern();
          }
          long end = System.currentTimeMillis();
          System.out.println("花费的时间为：" + (end - start));
  
          try {
              Thread.sleep(1000000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.gc();
      }
  }
  ```

  **未使用intern()结果：**

  <img src="images/261.png" alt="img" style="zoom:100%;" />

  <img src="images/263.png" alt="img" style="zoom:100%;" />

  **使用intern()结果：**

  <img src="images/262.png" alt="img" style="zoom:100%;" />

  <img src="images/264.png" alt="img" style="zoom:100%;" />

  使用intern()会在堆中new对象，同时会在字符串常量池中放入字符串，然后arr[i]指向常量池中的字符串，new出的对象因为无人指向，因此垃圾回收时会被回收，从而达到节省内存的目的。

* 大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern()方法，就会明显降低内存的大小。

### 6 StringTable的垃圾回收

```java
/**
 * String的垃圾回收:
 * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails
 */
public class StringGCTest {
    public static void main(String[] args) {
        for (int j = 0; j < 100000; j++) {  // 循环次数从100调到100000
            String.valueOf(j).intern();
        }
    }
}
```

**当循环次数为100时的结果：**

<img src="images/265.png" alt="img" style="zoom:100%;" />

**当循环次数为100000时的结果：**

<img src="images/266.png" alt="img" style="zoom:100%;" />

### 7 G1中的String去重操作

* 官方描述：http://openjdk.java.net/jeps/192
* 背景：对许多Java应用（有大的也有小的）做的测试得出如下结果：
  * 堆存活数据集合里面String对象占了25%
  * 堆存活数据集合里面重复的String对象有13.5%
  * String对象的平均长度时45
* 许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<font color=blue>**Java堆中存活的数据集合差不多25%是String对象**</font>，更进一步，这里面差不多一半String对象是重复的，重复的意思是说：string1.equals(string2) == true; 堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。
* 实现
  * 当垃圾收集器工作的时候，会访问堆上存活的对象。<font color=blue>**对每个访问的对象都会检查是否是候选的要去重的String对象**</font>。
  * 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重引用的String对象。
  * 使用一个hashtable来记录所有被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。
  * 如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。
  * 如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。
* 命令行选项
  * UseStringDeduplication(bool)：开启String去重，<font color=red>**默认是不开启的，需要手动开启**</font>。
  * PrintStringDeduplicationStatistics(bool)：打印详细的去重统计信息。
  * StringDeduplicationAgeThreshold(uintx)：达到这个年龄的String对象被认为是去重的候选对象

## 第14章 垃圾回收概述

### 1 什么是垃圾

<img src="images/268.png" alt="img" style="zoom:67%;" />

Java = (C++)--

---

* 垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。
* 关于垃圾收集有三个经典问题：
  * 哪些内存需要收集？
  * 什么时候回收垃圾？
  * 如何回收垃圾？
* 垃圾回收机制是Java的招牌能力，<font color=blue>**极大地提高了开发效率**</font>。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是<font color=blue>**面试的热点**</font>。

---

* 大厂面试题
  * <font color=red>**蚂蚁金服**</font>：
    * 你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1。
    * 一面：JVM GC算法有哪些，目前的JDK版本采用什么回收算法。
    * 一面：G1回收器讲下回收过程
    * GC是什么？为什么需要GC？
    * 一面：GC的两种判定方法？CMS收集器与G1收集器的特点。
  * <font color=red>**百度**</font>：
    * 说一下GC算法，分代回收说下
    * 垃圾回收策略和算法
  * <font color=red>**天猫**</font>：
    * 一面：JVM GC原理，JVM怎么回收内存？
    * 一面：CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？
  * <font color=red>**滴滴**</font>：
    * 一面：java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的。
  * <font color=red>**京东**</font>：
    * 你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1，包括原理，流程，优缺点，垃圾回收算法的实现原理。
  * <font color=red>**阿里**</font>：
    * 讲一讲垃圾回收算法
    * 什么情况下触发垃圾回收？
    * 如何选择合适的垃圾回收算法？
    * JVM有哪三种主要的垃圾回收器？
  * <font color=red>**字节跳动**</font>：
    * 常见的垃圾回收器算法有哪些，各有什么优劣？
    * system.gc()和runtime.gc()会做什么事情？
    * 一面：Java GC机制？GC Roots有哪些？
    * 二面：Java对象的回收方式，回收算法。
    * CMS和G1了解吗，CMS解决了什么问题，说一下回收的过程。
    * CMS回收停顿了几次，为什么需要停顿两次？

---

* 什么是垃圾（Garbage）？
  * 垃圾是指<font color=red>**在运行程序中没有任何指针指向的对象**</font>，这个对象就是需要被回收的垃圾。
  * 外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.
* 如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。

### 2 为什么需要GC

* 对于高级语言来说，一个基本认知是如果不进行垃圾回收，<font color=blue>**内存迟早都会被消耗完**</font>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。
* 处理释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存一道堆的一端，一遍<font color=blue>**JVM将整理出的内存分给新的对象**</font>。
* 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<font color=blue>**没有GC就不能保证应用程序的正常进行**</font>。而经常造成 STW的GC又跟不上实际的需求，所以才会不断地尝试对GC优化。

### 3 早期垃圾回收

* 在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行申请，并使用delete关键字进行内存释放。比如以下代码：

  ```c++
  MibBridge *pBridge = new cmBaseGroupBridge();
  // 如果注册失败，使用delete释放该对象所占内存区域
  if (pBridge->Register(kDestroy) != NO_ERROR)
      delete pBridge;
  ```

* 这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<font color=blue>**频繁申请和释放内存的管理负担**</font>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<font color=blue>**内存泄露**</font>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<font color=blue>**应用程序崩溃**</font>。

* 有了垃圾回收机制后，上述代码极有可能变成这样：

  ```c++
  MibBridge *pBridge = new cmBaseGroupBridge();
  pBridge->Register(kDestroy
  ```

* 现在，处理Java以外，C#、Python、Ruby等语言都是用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式已经成为现代语言必备的标准。

### 4 Java垃圾回收机制

* 自动内存管理，无需开发人员手动参与内存分配与回收，这样<font color=red>**降低内存泄露和内存溢出的风险**</font>。
  * 没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。
* 自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以<font color=red>**更专心地专注于业务开发**</font>。
* oracle官网关于垃圾回收的介绍：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html

---

* 担忧

  * 对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是异常灾难，最严重的就会<font color=blue>**弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力**</font>。
  * 此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时，快速地根据错误日志定位问题和解决问题。
  * 当需要排查各种内存溢出、内存泄露问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<font color=blue>**实施比亚的监控和调节**</font>。

* 应该关心哪些区域的回收？

  <img src="images/269.png" alt="img" style="zoom:67%;" />

---

* 垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区（Java虚拟机规范没有规定必须对方法区进行回收）的回收。
  * 其中，<font color=red>**Java堆是垃圾回收器的工作重点**</font>。
* 从次数上讲：
  * <font color=red>**频繁收集新生代**</font>
  * <font color=red>**较少 收集老年代**</font>
  * <font color=red>**基本不动方法区**</font>

## 第15章 垃圾回收相关算法

### 1 标记阶段：引用计数算法

* 垃圾标记阶段：对象存活判断
  * 在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<font color=blue>**需要区分出内存中哪些是存活对象，哪些是死亡的对象**</font>。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占的内存空间，因此这个过程我们可以称为<font color=blue>**垃圾标记阶段**</font>。
  * 那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何存活对象继续引用时，就可以还盘为已经死亡。
  * 判断对象存活一般由两种方式：<font color=red>**引用计数算法**</font>和<font color=red>**可达性分析算法**</font>。

---

* 方式1：引用计数算法

  * 引用计数算法（Reference Counting）比较简单，对每个对象保存一个整形的<font color=red>**引用计数器属性。用于记录对象被引用的情况**</font>。

  * 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1.只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。

  * 优点：<font color=blue>**实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性**</font>。

  * 缺点：

    * 它需要单独的字段存储计数器，这样的做法增加了<font color=blue>**存储空间的开销**</font>。
    * 没每次赋值都需要更新计数器，伴随着加法和减法的操作，这增加了<font color=blue>**时间开销**</font>。
    * 引用计数器有一个严重的问题，即无法处理<font color=blue>**循环引用**</font>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。

    <img src="images/270.png" alt="img" style="zoom:67%;" />

  * 代码示例

    ```java
    /**
     * -XX:+PrintGCDetails
     * 证明：java使用的不是引用计数算法
     */
    public class RefCountGC {
        // 这个成员属性唯一的作用就是占用一点内存
        private byte[] bigSize = new byte[5 * 1024 * 1024];  // 5MB
    
        Object reference = null;
    
        public static void main(String[] args) {
            RefCountGC obj1 = new RefCountGC();
            RefCountGC obj2 = new RefCountGC();
    
            obj1.reference = obj2;
            obj2.reference = obj1;
    
            obj1 = null;
            obj2 = null;
            // 显式的执行垃圾回收行为
            // 这里发生GC，obj1和obj2能否被回收？
            System.gc();
        }
    }
    ```

    如果采用循环引用会出现问题，如下图：

    <img src="images/271.png" alt="img" style="zoom:67%;" />

    **如果System.gc();被注释掉，输出结果如下**

    <img src="images/272.png" alt="img" style="zoom:100%;" />

    **如果System.gc();没被注释掉，输出结果如下**

    <img src="images/273.png" alt="img" style="zoom:100%;" />

---

* 小节
  * 引用计数算法，是很多语言的资源回收选择，例如隐人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。
  * 具体哪种最优是要看场景的，业界有大规模时间中仅保留引用技术机制，以提高吞吐量的尝试。
  * Java并没有选择引用计数，是因为其存在一个基本难题，也就是很难处理循环引用关系。
  * Python如何解决循环引用？
    * 手动解除：很好理解，就是在合适的实际，解除引用关系。
    * 使用弱引用weakref，weakref是Python提供的标准，只在解决循环引用。

### 2 标记阶段：可达性分析算法

* 方式二：可达性分析（或跟搜索算法、追踪性垃圾收集）

  * 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<font color=blue>**解决在引用计数算法中循环引用的问题，防止内存泄露的发生**</font>。

  * 相对于引用计数算法，这里的可达性分析就是<font color=red>**Java、C#**</font>选择的。这种类型的垃圾收集通常也叫做<font color=blue>**追踪性垃圾收集**</font>（Tracing Garbage Collection）。

  * 所谓“GC Roots”根集合就是一组必须活跃的引用。

  * 基本思路：

    * 可达性分析算法是以根集合（GC Roots）为起始点，按照从上至下的方式<font color=blue>**搜索被根对象集合所连接的目标是否可达**</font>。
    * 使用可达性分析算法后，内存中存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为<font color=red>**引用链（Reference Chain）**</font>。
    * 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。
    * 在可达性分析算法中，只有能被根对象集合直接或者间接连接的对象才是存活对象。

    <img src="images/274.png" alt="img" style="zoom:67%;" />

---

* 在Java语言中，GC Roots包括以下几类元素：

  * 虚拟机栈中引用的对象
    * 比如：各个线程被调用的方法中使用到的参数、局部变量等。
  * 本地方法栈JNI（通常说的本地方法）引用的对象
  * 方法区中静态属性引用的对象
    * 比如：Java类的引用类型静态变量
  * 方法区中常量引用的对象
    * 比如：字符串常量池（StringTable）里的引用
  * 所有被同步锁synchronized持有的对象
  * Java虚拟机内部的引用。
    * 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。
  * 反应java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

  <img src="images/275.png" alt="img" style="zoom:67%;" />

  * 除了这些固定的GC Roots集合以外，根据用户选择的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合，比如：分代收集和局部回收（Partial GC）。
    * 如果只针对Java堆中某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机字节的实现细节，更不是鼓励封闭的，这个区域的对象完全有可能被其他区域对象的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确定。

* 小技巧：

  * 由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那么它就是一个Root。

---

* 注意：
  * 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保证一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。
  * 这点也是导致GC进行时必须“Stop The World”的一个重要原因。
    * 即使是号称（几乎）不会发生停顿的CMS收集器中，<font color=red>**枚举根节点时也是必须要停顿的**</font>。

### 3 对象的finalization机制

* Java语言提供了对象终止（finalization）机制来允许开发人员提供能<font color=blue>**对象被销毁之前的自定义处理逻辑**</font>。
* 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。
* finalize()方法允许在子类中被重写，<font color=blue>**用于在对象被回收之前进行资源释放**</font>。通常在这个方法中进行一些资源释放和清理工作，比如关闭文件、套接字和数据库连接等。
* 永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：
  * 在finalize()时可能会导致对象复活。
  * finalize()方法的执行时没有时间保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。
  * 一个糟糕的finalize()会严重影响GC的性能。
* 从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数。

---

* 由于finalize()方法的存在，<font color=blue>**虚拟机中的对象一般处于三种可能的状态**</font>。

  * 如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，次对象需要被回收，但事实上，也并不是“非死不可”的，这时候他们展示处于“缓刑”阶段。<font color=red>**一个无法触及的对象有可能在某一个条件下“复活”自己**</font>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：
    * <font color=red>**可触及的**</font>：从根节点开始，可以到达这个对象。
    * <font color=red>**可复活的**</font>：对象的所有引用都被释放，但是对象有可能在finalize()中复活。
    * <font color=red>**不可触及的**</font>：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<font color=blue>**finalize()只会被调用一次**</font>。
  * 以上三种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及是才可能被回收。

* 回收对象的具体过程：判断一个对象objA是否可回收，至少要经历两次编辑过程：

  1. 如果对象objA到GC Roots没有引用链，则进行第一次标记。

  2. 进行筛选，判断次对象是否有必要执行finalize()方法

     ① 如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机将会把finalize()方法视为“没有必要执行”，objA被判定为不可触及的。

     ② 如果对象onjA重写了finalize()方法，且还未执行过，那么objA会被插入F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发finalize()方法执行。

     <img src="images/276.png" alt="img" style="zoom:100%;" />

     ③ <font color=red>**finalize()方法是对象逃脱死亡的最后机会**</font>，稍后GC会对F-Queue队列中的对象进行第二次标记。<font color=blue>**如果objA在finalize()方法中与引用链上的任何一个对象建立了联系**</font>，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用的情况。这种情况下，finalize()方法不会再次被调用，对象会直接编程不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。

* 代码演示

  ```java
  /**
   * 测试Object类中finalize()方法，即对象的finalization机制。
   */
  public class CanReliveObj {
      public static CanReliveObj obj;  // 类变量，属于 GC Root
  
      // 此方法只能被调用一次
      @Override
      protected void finalize() throws Throwable {
          super.finalize();
          System.out.println("调用当前类重写的finalize()方法");
          obj = this;  // 当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系
      }
  
      public static void main(String[] args) {
          try {
              obj = new CanReliveObj();
              // 对象第一次成功拯救自己
              obj = null;
              System.gc();  // 调用垃圾回收器
              System.out.println("第1次 gc");
              // 因为Finalizer线程优先级很低，暂停2秒，以等待它
              Thread.sleep(2000);
              if (obj == null) {
                  System.out.println("obj is dead");
              } else {
                  System.out.println("obj is still alive");
              }
              System.out.println("第2次 gc");
              // 下面这段代码与上面的完全相同，但是这次自救却失败了
              obj = null;
              System.gc();
              // 因为Finalizer线程优先级很低，暂停2秒，以等待它
              Thread.sleep(2000);
              if (obj == null) {
                  System.out.println("obj is dead");
              } else {
                  System.out.println("obj is still alive");
              }
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      }
  }
  ```

  **结果：**

  ​			调用当前类重写的finalize()方法

  ​			第1次 gc

  ​			obj is still alive

  ​			第2次 gc

  ​			obj is dead

### 4 MAT与JProfiler的GC Roots溯源

* MAT简介
  * MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄露以及查看内存消耗情况。
  * MAT是基于Eclipse开发的，是一款免费的性能分析工具。
  * 大家可以在http://www.eclipse.org/mat/下载并使用MAT。

---

* 获取dump文件

  * 方式1：命令行使用jmap

    <img src="images/277.png" alt="img" style="zoom:100%;" />

  * 方式2：使用JVisualVM导出

    * 捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。
    * 可通过以下方法捕获heap dump：
      * 在左侧“Application”（应用程序）子窗口中左击相应的应用程序，选择Heap Dump（堆DUmp）。
      * 在Monitor（监视）字标签页中点击Heap Dump（堆Dump）按钮。
    * 本地应用程序的Heap dumps作为应用程序标签页的一个标签页打开。同时，heap dump在左侧的Application（应用程序）栏中对应一个含有时间戳的节点。右击这个节点的save as（另存为）即可将heap dump保存到本地。

  * dump文件分析

    ```java
    public class GCRootsTest {
        public static void main(String[] args) {
            List<Object> numList = new ArrayList<>();
            Date birth = new Date();
    
            for (int i = 0; i < 100; i++) {
                numList.add(String.valueOf(i));
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
    
            System.out.println("数据添加完毕，请操作：");
            new Scanner(System.in).next();
            numList = null;
            birth = null;
    
            System.out.println("numList、birth已置空，请操作：");
            new Scanner(System.in).next();
    
            System.out.println("结束");
        }
    }
    ```

    <img src="images/278.png" alt="img" style="zoom:100%;" />

    <img src="images/279.png" alt="img" style="zoom:100%;" />

    <img src="images/280.png" alt="img" style="zoom:100%;" />

    置空numList和birth后通过分析dump文件可以看到ArrayList和Date没有了

    <img src="images/281.png" alt="img" style="zoom:100%;" />

---

* 使用JProfiler查找某对象的引用链（GC 溯源）

  <img src="images/282.png" alt="img" style="zoom:100%;" />

  <img src="images/283.png" alt="img" style="zoom:100%;" />

  <img src="images/284.png" alt="img" style="zoom:100%;" />

---

* 使用JProfiler分析OOM

  ```java
  /**
   * -Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError
   */
  public class HeapOOM {
      byte[] buffer = new byte[1 * 1024 * 1024];  // 1MB
  
      public static void main(String[] args) {
          ArrayList<HeapOOM> list = new ArrayList<>();
  
          int count = 0;
          try{
              while(true){
                  list.add(new HeapOOM());
                  count++;
              }
          }catch (Throwable e){
              System.out.println("count = " + count);
              e.printStackTrace();
          }
      }
  }
  ```

  <img src="images/285.png" alt="img" style="zoom:100%;" />

  -XX:+HeapDumpOnOutOfMemoryError：出现OOM是会生成Dump文件

  <img src="images/286.png" alt="img" style="zoom:100%;" />

  双击用JProfiler打开此文件

  <img src="images/287.png" alt="img" style="zoom:100%;" />

  <img src="images/288.png" alt="img" style="zoom:100%;" />

### 5 清除阶段：标记-清除算法

* 垃圾清除阶段
  * 当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。
  * 目前在JVM中比较常见的三种垃圾收集算法是<font color=red>**标记-清除算法（Mark-Sweep）、复制算法（Copying）、标记-压缩算法（Mark-Compact）**</font>。

---

* 标记-清除（Mark-Sweep）算法

  * 背景：标记-清除（Mark-Sweep）算法是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于Lisp语言。
  * 执行过程：当中的有效内存空间（avaiable memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项是标记，第二项是清除。
    * <font color=blue>**标记**</font>：Collector从引用根节点开始比那里，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。
    * <font color=blue>**清除**</font>：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在Header中没有标记为可达对象，则将其回收。

  <img src="images/289.png" alt="img" style="zoom:67%;" />

  * 缺点
    * 效率不算高
    * 在进行GC的时候，需要停止整个应用程序，导致用户体验差
    * 这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表，大对象可能放不下
  * 注意：何为清除？
    * 这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表中。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。

### 6 清除阶段：复制算法

* 复制（Copying）算法

  * 为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器（CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky本人成功地将该算法引入到Lisp语言的一个实现版本中。
  * 核心思想：将活着的内存空间分为两块，每次使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。

  <img src="images/290.png" alt="img" style="zoom:67%;" />

  * 优点：

    * 没有标记和清除过程（我感觉这句话不对），实现简单，运行高效
    * 复制过去后保证了空间的连续性，不会出现“碎片”问题

  * 缺点：

    * 此算法的缺点也是非常明显的，就是需要两倍的内存空间。
    * 对于G1这种分拆称为大量region的GC，赋值而不是移动，意味着GC需要维护region之间对象引用关系，不管内存占用还是时间，开销也不小。

  * <font color=blue>**特别的：**</font>

    * 如果系统中的垃圾对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量数量非常低效率才高。

  * 应用场景

    <img src="images/291.png" alt="img" style="zoom:67%;" />

### 7 清除阶段：标记-压缩算法

* 标记-压缩（或标记-整理、Mark-Compact）算法

  * 背景：复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代进程发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<font color=red>**基于老年代垃圾回收的特性，需要使用其他的算法**</font>。
  * 标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。
  * 1970年前后，G.L.Steele、C.J.Chene和D.S.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都是用了标记-压缩算法或其他改进版本。

  <img src="images/292.png" alt="img" style="zoom:67%;" />

  * 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<font color=red>**标记-清除-压缩（Mark-Sweep-Compact）算法**</font>。

  * 标记-压缩算法 和 标记-清除算法本质区别
    * 标记-压缩算法是<font color=blue>**移动式的**</font>。
    * 标记-清除算法是一种<font color=blue>**非移动式的回收算法**</font>。
    * 是否移动回收后的存活对象是一项优缺点并存的风险决策。
  * 可以看到，标记的存活对象将会被整理，按照内存地址一次排列，而未被标记的内存会被清理掉。如此以来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。
  * 优点：
    * 消除了标记-清除算法中，内存区域分散的缺点，我们需要给新对象分配内存是，JVM只需要持有一个内存的起始地址即可。
    * 消除了赋值算法当中，内存减半的高额代价。
  * 缺点：
    * 从效率上来说，标记-整理算法要低于另外两种算法（标记-清除算法、复制算法）
    * 移动对象的同时，如果对象被其他对象引用，则还需调整引用的地址
    * 移动的过程中，需要全称暂停用户应用程序。即STW。（其他两种算法也有这个问题）

### 8 小节

<img src="images/293.png" alt="img" style="zoom:80%;" />

效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。

而为了尽量兼顾上面的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除算法多了一个整理内存的阶段。

### 9 分代收集算法

* <font color=red size=4>**难道就没有一种最优的算法吗？**</font>

  * 回答：没有，没有最好的算法，只有最适合的算法。

* 分代收集算法

  * 前面所有这些算法中，并没有一种算法可以完全替代其他算法，他们都具有自己独特的优势和特点。分代收集算法应运而生。

  * 分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<font color=blue>**不同生命周期的对象可以采取不同的收集方式，一遍提高回收效率**</font>。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。

  * 在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如<font color=blue>**Http请求中的Session对象、线程、Socket连接**</font>，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期比较短，比如：<font color=blue>**String对象**</font>，由于其不变性的特性，系统会产生大量这些对象，有些对象甚至只用一次即可回收。

  * <font color=red>**目前几乎所有的GC都是采用分代收集（Generational Collecting）算法执行垃圾回收的**</font>。

  * 在Hotspot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。

    * 年轻代（Young Gen）

      年轻代特点：区域相对于老年代较小，对象声明周期短、存活率低，回收频繁。这种情况<font color=blue>**复制算法**</font>是回收整理速度最快的。赋值算法的效率之和当前存活对象大小有关，因此很适用于年轻代的回收。而赋值算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。

    * 老年代（Tenured Gen）

      老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。这种情况下存在大量存活率高的对象，赋值算法变得明显不合适。一般是由<font color=blue>**标记-清除算法 与 标记-压缩算法**</font>的混合实现。

      * Mark阶段的开销与存货对象的数量成正比。
      * Sweep阶段的开销与所管理区域的大小成正相关。
      * Compact阶段的开销与存货对象的数据成正比。

      以Hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。

---

* 分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。

### 10 增量收集算法、分区算法

* 这两种算法都是为了解决STW的问题
* 增量收集算法（从时间角度提高低延迟）
  * 上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<font color=blue>**Stop the World**</font>状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，<font color=blue>**将严重影响用户体验或者系统的稳定性**</font>。为了解决这个问题，即对实时垃圾收集算法的研究导致了增量收集（Incremental Collecting）算法的诞生。
  * 基本思想：如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序交替执行。每次，<font color=blue>**垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成**</font>。
  * 总的来说，增量收集算法的基础仍然是传统的标记-清除算法和复制算法。增量收集算法通过<font color=red>**对线程间冲突的妥善处理，允许垃圾线程以分阶段的方式完成标记、清理或复制工作**</font>。
  * 缺点：
    * 使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总成本上升，<font color=blue>**造成系统吞吐量的下降**</font>。

---

* 分区算法（从空间角度提高低延迟）

  * 一般来说，在相同条件下，堆空间越大，一次GC所需要的时间越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，格局目标的停顿时间，每次合理地回收若干小区间，而不是整个堆空间，从而减少一次GC锁产生的停顿。
  * 分代算法将按照对象的生命周期长短划分为两个部分，分区算法将整个堆空间划分成连续的不同小区间region。
  * 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少峰小区间。

  <img src="images/294.png" alt="img" style="zoom:67%;" />

---

* 写在最后：
  * 注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前言GC都是符合算法，并且并行和并发兼备。

## 第16章 垃圾回收相关概念

### 1 System.gc()

* 默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，<font color=blue>**会显式触发Full GC**</font>，同时对老年代和新生代以及方法区进行回收，尝试释放被丢弃对象占用的内存。

* 然而System.gc()调用附带一个免责声明，无法保证对垃圾回收器的调用。

* JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，<font color=blue>**无需手动触发，否则就过于麻烦了**</font>。在一些特殊情况下，如我们正在编写一个基准测试，我们可以在运行之间调用System.gc()。

  ```java
  public class SystemGCTest {
      public static void main(String[] args) {
          new SystemGCTest();
          System.gc();  // 提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc
          // 与Runtime.getRuntime().gc();的作用一样。
  
          System.runFinalization();  // 强制调用失去引用的对象的finalize()方法
      }
  
      @Override
      protected void finalize() throws Throwable {
          super.finalize();
          System.out.println("SystemGCTest 重写了finalize()");
      }
  }
  ```

* 一个例子

  ```java
  /**
   * -XX:+PrintGCDetails
   *
   * @author shkstart  shkstart@126.com
   * @create 2020  14:57
   */
  public class LocalVarGC {
      public void localvarGC1() {
          byte[] buffer = new byte[10 * 1024 * 1024];  // 10MB
          System.gc();
      }
  
      public void localvarGC2() {
          byte[] buffer = new byte[10 * 1024 * 1024];
          buffer = null;
          System.gc();
      }
  
      public void localvarGC3() {
          {
              byte[] buffer = new byte[10 * 1024 * 1024];
          }
          System.gc();
      }
  
      public void localvarGC4() {
          {
              byte[] buffer = new byte[10 * 1024 * 1024];
          }
          int value = 10;
          System.gc();
      }
  
      public void localvarGC5() {
          localvarGC1();
          System.gc();
      }
  
      public static void main(String[] args) {
          LocalVarGC local = new LocalVarGC();
          local.localvarGC1();
      }
  }
  ```

  **如果主函数中调用localvarGC1()，结果：**

  <img src="images/295.png" alt="img" style="zoom:100%;" />

  **如果主函数中调用localvarGC2()，结果：**

  <img src="images/296.png" alt="img" style="zoom:100%;" />

  **如果主函数中调用localvarGC3()，结果：**

  <img src="images/297.png" alt="img" style="zoom:100%;" />

  <img src="images/298.png" alt="img" style="zoom:100%;" />

  <img src="images/299.png" alt="img" style="zoom:100%;" />

  **如果主函数中调用localvarGC4()，结果：**

  <img src="images/300.png" alt="img" style="zoom:100%;" />

  <img src="images/301.png" alt="img" style="zoom:100%;" />

  <img src="images/302.png" alt="img" style="zoom:100%;" />

  **如果主函数中调用localvarGC5()，结果：**

  <img src="images/303.png" alt="img" style="zoom:100%;" />

### 2 内存溢出（OOM）与内存泄露（Memory Leak）

* 内存溢出相对于内存泄露来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。
* 由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，在成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。
* 大多数情况下，GC会进行各种年龄段的垃圾回收，是在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。
* javadoc中对OutOfMemoryError的解释是：<font color=blue>**没有空闲内存，并且垃圾回收器也无法提供更多内存**</font>。

---

* 首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：

  1. **Java虚拟机的堆内存设置不够。**

     比如：可能的内存泄露问题；也很有可能就是堆的大小不合适，比如我们要处理比价可观的数据量，但是没有显示指定JVM堆大小或者指定数值偏小。我们可以通过-Xms、-Xmx来调整。

  2. **代码中创建了大量大对象，并且长时间不能被垃圾回收器收集（存在被引用）。**

     对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不在需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常常见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会被编辑出来和永久代相关：“<font color=blue>**java.lang.OutOfMemoryError:PermGen space**</font>”。

     随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了“<font color=blue>**java.lang.OutOfMemoryError:Metaspace**</font>”。直接内存不足，也会导致OOM。

* 这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。

  * 例如：在引用机制分析中，设计JVM回去尝试回收<font color=red>**软引用指向的对象等**</font>。
  * 在java.nio.BIts.reserveMemory()方法中，我们能清楚地看到，System,gc()会被调用，以清理空间。

* 当然，也不是在任何情况下垃圾收集器都会被触发的。

  * 比如，我们去分配一个超大对象，累死一个超大数组超过堆的最大值，JVM可以判断出垃圾回收并不能解决这个问题，所以直接抛出OutOfMemoryError。

---

* 内存泄露

  * 也称作“存储渗漏”。<font color=red>**严格来说**</font>，<font color=blue>**只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫做内存泄露**</font>。

  * 但实际情况很多时候一些不太好实践（或疏忽）会导致对象的生命周期变得很长甚至OOM，也可以叫做<font color=red>**宽泛意义上的“内存泄露”**</font>。

  * 尽管内存泄露并不会立刻引起程序的崩溃，但是一旦发生内存泄露，程序中的可用内存就会被逐步蚕食，直到耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃。

  * 注意，这里的存储空间并不是指物理内存，而是值虚拟机内存的大小，这个虚拟内存大小取决于磁盘交换区设定的大小。

  * 内存泄露的例子

    <img src="images/304.png" alt="img" style="zoom:80%;" />

    不要举“引用计数”导致内存泄露的例子，这是因为Java没有使用引用计数作为标记的算法。

    1. 单例模式

       单例的生命周期和应用程序时一样长，所以单例应用程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄露的产生。

    2. 一些提供close的资源未关闭导致内存泄露

       数据库连接（dataSource.getConnection()），网络连接（socket）和io连接必须手动close，否则是不能被回收的。

### 3 Stop The World

* Stop The World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<font color=blue>**停顿产生时整个应用恒旭线程都会被暂停，没有任何响应**</font>，有点像卡死的感觉，这个停顿称为STW.
  * 可达性分析算法中枚举根节点（GC Roots）会导致所以Java执行线程停顿。
    * 分析工作必须在一个能确保一致性的快照中进行。
    * 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上。
    * <font color=blue>**如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确定无法保证**</font>
* 被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们要减少STW的发生。
* STW事件和采用哪款GC无关，所有的GC都有这个事件。
* 哪怕是G1也不能完全避免Stop The World情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。
* STW是JVM<font color=blue>**在后台自动发起和自动完成**</font>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。
* 开发中不用用System.gc()；会导致Stop The World的发生。

---

* STW代码演示：启动两个线程，一个一秒钟打印出一条信息，另一个负责执行System.gc()等，这会导致第一个线程不能一秒钟打印出一条信息。

  ```java
  public class StopTheWorldDemo {
      public static class WorkThread extends Thread {
          List<byte[]> list = new ArrayList<byte[]>();
  
          @Override
          public void run() {
              try {
                  while (true) {
                      for (int i = 0; i < 1000; i++) {
                          byte[] buffer = new byte[1024];
                          list.add(buffer);
                      }
  
                      if (list.size() > 10000) {
                          list.clear();
                          System.gc();  // 会触发full gc，进而会出现STW事件
                      }
                  }
              } catch (Exception ex) {
                  ex.printStackTrace();
              }
          }
      }
  
      public static class PrintThread extends Thread {
          public final long startTime = System.currentTimeMillis();
  
          public void run() {
              try {
                  while (true) {
                      // 每秒打印时间信息
                      long t = System.currentTimeMillis() - startTime;
                      System.out.println(t / 1000 + "." + t % 1000);
                      Thread.sleep(1000);
                  }
              } catch (Exception ex) {
                  ex.printStackTrace();
              }
          }
      }
  
      public static void main(String[] args) {
          WorkThread w = new WorkThread();
          PrintThread p = new PrintThread();
          w.start();
          p.start();
      }
  }
  ```

  **结果：**

  ​			0.1

  ​			1.37

  ​			2.39

  ​			3.44

  ​			......

### 4 垃圾回收的并行与并发

* 并发（Concurrent）

  * 在操作系统中，是指<font color=blue>**一个时间段中**</font>有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。

  * 并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。图下图，三个程序在运行

    <img src="images/305.png" alt="img" style="zoom:67%;" />

* 并行（Parallel）

  * 当系统有有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，当两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Parallel）。

  * 其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。

  * 适用于科学计算，后台处理等若交互场景。

    <img src="images/306.png" alt="img" style="zoom:67%;" />

* 并发 ***vs*** 并行

  * 并发，**指的是多个事情**，<font color=red>**在同一时间段内同时发生了**</font>。
  * 并行，**指的是多个事情**，<font color=red>**在同一时间点上同时发生了**</font>。
  * 并发的多个任务之间是相互抢占资源的。
  * 并行的多个任务之间是不相互抢占资源的。
  * 只有在多个CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。

---

* 垃圾回收的并发和并行

  并发和并行，在谈论垃圾收集器的上下文语境中，他们可以解释如下：

  * 并行（Parallel）：指<font color=blue>**多条垃圾收集线程并行工作**</font>，但此时用户线程处于等待状态

    * 例如ParNew、Parallel Scavenge、Parallel Old；

  * 串行（Serial）

    * 相对于并行的概念，单线程执行。
    * 如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收万，再启动程序的线程。

    <img src="images/307.png" alt="img" style="zoom:67%;" />

  * 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。

    * 用户程序继续运行，而垃圾收集程序运行在另一个CPU上；
    * 如：CMS、G1

### 5 安全点与安全区域

* 安全点（Safepoint）

  * 程序执行时并非在所有地方都能停顿下来GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。

  * Safe Point的选择很重要，<font color=blue>**如果太少可能会导致GC等待的时间太长，如果太频繁可能会导致运行时的性能问题**</font>。大部分指令的执行时间都非常短暂，通常会根据“<font color=red>**是否具有让程序长时间执行的特征**</font>”为标准。比如：选择一些执行时间比较长的指令作为Safe Point，如<font color=blue>**方法调用、循环跳转和异常跳转**</font>等。

  * **如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？**

    * 抢先式中断：（目前没有虚拟机采用了）

      首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。

    * 主动式中断：

      设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志位真，则让自己进行中断挂起。

---

* 安全区域（Safe Region）
  * Safepoint机制保证了线程执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤起。对于这种情况，就需要安全区域（Safe Region）来解决。
  * <font color=blue>**安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的**</font>。我们也可以把Safe Region看做被扩展了的Safepoint。实际执行时：

* 1. 当线程运行到Safe Region的代码时，首先表示已经进入了Safe Region，如果这段时间内发生了GC，JVM会忽略表示为Safe Region状态的线程；
  2. 当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待收到可以安全离开Safe Region的信号为止。

### 6 再谈引用：强引用

* 再谈引用

  * 我们希望能描述这样哟类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。

  * [既<font color=blue>**偏门**</font>又非常<font color=blue>**高频**</font>的面试题]强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？

  * 在JKD1.2版本之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，<font color=red>**这4中引用强度一次逐渐减弱**</font>。

  * 除强引用外，其他3种引用均可以在java.lang.ref包中招待他们的身影。如下图，显示了这3中引用类型对应的类，开发人员可以在应用程序中直接使用他们。

    <img src="images/309.png" alt="img" style="zoom:100%;" />

* Reference子类中只有终结器引用时保内可见的，其他3引用类型均是public，可以在应用程序中直接使用

  * <font color=blue>**强引用（String Reference）**</font>:最传统的“引用”的定义，是指程序代码之中普遍存在的引用赋值，即类似“Object obj = new Object();”这种引用关系。<font color=red>**无论任何情况下，只要强引用关系还存在，垃圾收集器永远不会回收掉被引用的对象**</font>。<font color=blue>**死也不回收**</font>。
  * <font color=blue>**软引用（Soft Reference）**</font>:在系统将要发生内存溢出之前，将会把这些对象列入回收范围中进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。<font color=blue>**内存不足即回收**</font>。
  * <font color=blue>**软引用（Weak Reference）**</font>:被弱引用关联的对象只能生存到下一次垃圾回收之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。<font color=blue>**发现即回收**</font>。
  * <font color=blue>**虚引用（Phantom Reference）**</font>:一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为对象设置虚引用关联的<font color=red>**唯一目的就是能在这个对象被垃圾回收器回收时得到一个系统通知**</font>。

---

* 强引用（Strong Reference）------死不回收

  * 在Java程序中，最常见的引用类型是强引用（<font color=blue>**普通系统99%以上都是强引用**</font>），也就是我们最常见的普通对象引用，<font color=blue>**也是默认的引用类型**</font>。
  * 当在Java语言中使用new操作符创建一个新对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。
  * <font color=blue>**强引用的对象是可触及的，垃圾收集器永远不会回收掉被强引用的对象**</font>。
  * 对于一个普通的对象，如果没有其他引用关系，只要超过引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。
  * 相对的，软引用、弱引用和虚引用的随想是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，<font color=blue>**强引用是造成java内存泄露的主要原因之一**</font>。

  <img src="images/310.png" alt="img" style="zoom:67%;" />

  * 强引用特点：
    * 强引用可以直接访问目标对象。
    * 强引用所指向的对象任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用锁指向的对象。
    * 强引用可能导致内存泄露。

### 7 再谈引用：软引用

* 软引用（Soft Reference）------内存不足即回收

  * 弱引用是用来描述一些还有用，但非必须的对象。<font color=blue>**只被软引用关联的对象，在系统将要发生内存溢出前，会把这些对象列入回收范围之中进行第二次回收（第一次回收就是正常回收没有引用指向的对象）**</font>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。

  * 软引用通常用来实现命案的缓存。比如：<font color=blue>**告诉缓存**</font>就用到了软引用（例如mybatis源码中用到了软引用）。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

  * 垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把语言存放到一个引用队列（Reference Queue）。

  * 类似于弱引用，只不过Java虚拟机会疆良让软引用存活时间长一些，迫不得已才清理。

  * 代码演示

    ```java
    /**
     * 软引用的测试：内存不足即回收
     * -Xms10m -Xmx10m
     */
    public class SoftReferenceTest {
        public static class User {
            public User(int id, String name) {
                this.id = id;
                this.name = name;
            }
    
            public int id;
            public String name;
    
            @Override
            public String toString() {
                return "[id=" + id + ", name=" + name + "] ";
            }
        }
    
        public static void main(String[] args) {
            // 创建对象，建立软引用
            // SoftReference<User> userSoftRef = new SoftReference<User>(new User(1, "wxx"));
            // 上面的一行代码，等价于如下的三行代码
            User u1 = new User(1, "wxx");
            SoftReference<User> userSoftRef = new SoftReference<User>(u1);
            u1 = null;  // 取消强引用
    
            // 从软引用中重新获得强引用对象
            System.out.println(userSoftRef.get());
    
            System.gc();
            System.out.println("After GC:");
            //垃圾回收之后获得软引用中的对象
            System.out.println(userSoftRef.get());  // 由于堆空间内存足够，所有不会回收软引用的可达对象。
    
            try {
                // 让系统认为内存资源不够，会回收软引用
                // byte[] b = new byte[1024 * 1024 * 7];
                // 让系统认为内存资源紧张，会回收软引用
                byte[] b = new byte[1024 * 7168 - 610 * 1024];
            } catch (Throwable e) {
                e.printStackTrace();
            } finally {
                //再次从软引用中获取数据
                System.out.println(userSoftRef.get());  // 在报OOM之前，垃圾回收器会回收软引用的可达对象。
            }
        }
    }
    ```

    **结果：**

    ​			[id=1, name=wxx] 

    ​			After GC:

    ​			[id=1, name=wxx] 

    ​			null

    想要不报OOM回收软引用需要精准控制字节数组b的大小，可以增加参数-XX:+PrintGCDetails确定字节数组大小

### 8 再谈引用：弱引用

* 弱引用（Weak Reference）------发现即回收

  * 弱引用也是用来描述那些非必须对象，<font color=blue>**只被弱引用关联的对象只能生存到下一次垃圾收集发生为止**</font>。在系统GC时，只要发现弱引用，不管系统堆空间是否充足，都会回收掉被弱引用关联的对象。

  * 但是，由于垃圾回收器的线程优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，<font color=blue>**弱引用对象可以存在较长的时间**</font>。

  * 弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。

  * <font color=blue>**软引用、弱引用都非常适合来保存那些可有可无的缓存数据**</font>。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在在相当长的时间，从而起到加速系统的作用。

  * 在JDK1.2版之后提供了java.lang.ref.WeakReference类来实现弱引用。

    ```java
    /**
     * 弱引用的测试
     */
    public class WeakReferenceTest {
        public static class User {
            public User(int id, String name) {
                this.id = id;
                this.name = name;
            }
    
            public int id;
            public String name;
    
            @Override
            public String toString() {
                return "[id=" + id + ", name=" + name + "] ";
            }
        }
    
        public static void main(String[] args) {
            //构造了弱引用
            WeakReference<User> userWeakRef = new WeakReference<User>(new User(1, "wxx"));
            //从弱引用中重新获取对象
            System.out.println(userWeakRef.get());
    
            System.gc();
            // 不管当前内存空间足够与否，都会回收它的内存
            System.out.println("After GC:");
            //重新尝试从弱引用中获取对象
            System.out.println(userWeakRef.get());
        }
    }
    ```

    **结果：**

    ​			[id=1, name=wxx] 

    ​			After GC:

    ​			null

  * <font color=blue>**弱引用对象与软引用对象的最大不同**</font>就在于，当GC进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。<font color=blue>**弱引用对象更容易、更快的被GC回收**</font>。

  * **面试题：你再开发中使用过WeakHashMap吗？**

    ```java
    public class WeakHashMap<K,V>
        extends AbstractMap<K,V>
        implements Map<K,V> {
        // ...
        
        private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V> {
            // ...
        }
        
        // ...
    }
    ```

### 9 再谈引用：虚引用

* 虚引用（Phantom Reference）------对象回收跟踪

  * 也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。

  * 一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么塔和没有引用几乎是一样的，随时都可能 被垃圾回收期回收。

  * 它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。

  * <font color=blue>**为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象收集器回收时收到一个系统通知**</font>。

  * 虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收期准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以同志应用程序对象的回收情况。

  * <font color=blue>**由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录**</font>。

  * 在JDK1.2版之后提供了PhantomReference类来实现虚引用。

    ```java
    public class PhantomReferenceTest {
        public static PhantomReferenceTest obj;  // 当前类对象的声明
        static ReferenceQueue<PhantomReferenceTest> phantomQueue = null;  // 引用队列
    
        public static class CheckRefQueue extends Thread {
            @Override
            public void run() {
                while (true) {
                    if (phantomQueue != null) {
                        PhantomReference<PhantomReferenceTest> objt = null;
                        try {
                            objt = (PhantomReference<PhantomReferenceTest>) phantomQueue.remove();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        if (objt != null) {
                            System.out.println("追踪垃圾回收过程：PhantomReferenceTest实例被GC了");
                        }
                    }
                }
            }
        }
    
        @Override
        protected void finalize() throws Throwable {  // finalize()方法只能被调用一次！
            super.finalize();
            System.out.println("调用当前类的finalize()方法");
            obj = this;
        }
    
        public static void main(String[] args) {
            Thread t = new CheckRefQueue();
            t.setDaemon(true);  // 设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。
            t.start();
    
            phantomQueue = new ReferenceQueue<PhantomReferenceTest>();
            obj = new PhantomReferenceTest();
            // 构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列
            PhantomReference<PhantomReferenceTest> phantomRef = new PhantomReference<PhantomReferenceTest>(obj, phantomQueue);
    
            try {
                // 不可获取虚引用中的对象
                System.out.println(phantomRef.get());
    
                // 将强引用去除
                obj = null;
                // 第一次进行GC,由于对象可复活，GC无法回收该对象
                System.gc();
                Thread.sleep(1000);
                if (obj == null) {
                    System.out.println("obj 是 null");
                } else {
                    System.out.println("obj 可用");
                }
                System.out.println("第 2 次 gc");
                obj = null;
                System.gc();  //一旦将obj对象回收，就会将此虚引用存放到引用队列中。
                Thread.sleep(1000);
                if (obj == null) {
                    System.out.println("obj 是 null");
                } else {
                    System.out.println("obj 可用");
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    ```

    **结果：**

    ​			null

    ​			调用当前类的finalize()方法

    ​			obj 可用

    ​			第 2 次 gc

    ​			追踪垃圾回收过程：PhantomReferenceTest实例被GC了

    ​			obj 是 null

### 10 再谈引用：终结器引用（Final reference）

* 它用以实现对象的finalize()方法，也可以成为终接器引用。
* 无需手动编码，其内部配合引用 队列使用。
* 在GC时，终接器引用入队。由Finalizer线程通过终接器引用找到被引用的对象并调用它的finalize()方法，第二次GC时才能回收被引用对象。

## 第17章 垃圾回收器

### 1 GC分类与性能指标

* 垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。
* 由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。
* 从不同的角度分析垃圾收集器，可以将GC分为不同的类型。

---

* 查看Java不同版本的新特性，可以从三个层面分析：
  1. 语法层面 ：Lambda表达式、switch、自动装箱、自动拆箱、enum、<>、...
  2. API层面：Stream API、新的日期时间、Optional、String、集合框架......
  3. 底层优化：JVM的优化、GC的变化、元空间、静态域、字符串常量池......

---

* 垃圾回收器分类

  * 按照<font color=blue>**线程数**</font>分，可以分为串行垃圾回收器和并行垃圾回收器。

    <img src="images/311.png" alt="img" style="zoom:67%;" />

    * 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作此时工作线程被暂停，直到垃圾收集工作结束。
      * 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器的并发回收器。所以，<font color=blue>**串行回收默认被应用在客户端的Client模式下的JVM中**</font>。
      * 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。
    * 和串行回收相反，并行手机可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop the world"机制。

  * 按照<font color=blue>**工作模式**</font>分，可以分为并发式垃圾回收器和独占式垃圾回收器。

    * 并发式垃圾回收器与应用程序交替工作，以尽可能减少应用程序的停顿时间。
    * 独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序转给你所有用户线程，知道垃圾回收过程完全结束。

    <img src="images/308.png" alt="img" style="zoom:67%;" />

  * 按照<font color=blue>**碎片处理方式**</font>分，可以分为压缩式垃圾回收器和非压缩式垃圾回收器。

    * 压缩式垃圾回收器在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。再分配对象空间使用：指针碰撞。
    * 非压缩式垃圾收集器不进行这步操作。再分配对象空间使用：空闲列表。

  * 按照<font color=blue>**工作的内存区间**</font>分，可以分为新生代垃圾回收器和老年代垃圾回收器。

---

* 评估GC的性能指标
  * <font color=red>**吞吐量：运行用户代码的时间占总运行时间的比例**</font>。
    * 总运行时间 = 程序的运行时间 + 垃圾回收的时间
  * 垃圾收集开销：吞吐量的补数，垃圾收集时间与总运行时间的比例。
  * <font color=red>**暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间**</font>。
  * 收集频率，相对于应用程序的执行，收集操作发生的频率。
  * <font color=red>**内存占用：Java堆区所占的内存大小**</font>。
  * 快速：一个对象从诞生到被回收所经历的时间。
* 关于GC的性能指标三项标红的内容共同构成了一个“不可能三角”。三者总体表现会随着技术进步而越来越好。一款优秀的收集器通常最多满足其中的两项。
* 这三项里，暂停时间的重要性日益凸显。因为随着硬件的发展，内存占用多谢越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响。而内存的扩大，对延迟反而带来负面效果。
* 简单来说，主要抓住两点：<font color=red>**吞吐量、暂停时间**</font>。

---

* 评估GC的性能指标 ：吞吐量（throughtput）

  * 吞吐量就是CPU用于运行用户代码的时间与CPU总耗时的比值，即吞吐量 = 运行用户代码时间 / (程序的运行时间 + 垃圾回收的时间)。

    * 比如：虚拟机总共运行100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%（99%是个很好的吞吐量）。

  * 这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量 的应用程序有更长的时间基准，快速响应是不必考虑的。

  * 吞吐量有限，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4

    <img src="images/312.png" alt="img" style="zoom:67%;" />

* 评估GC的性能指标 ：暂停时间（pause time）

  * "暂停时间"是指一个时间段内应用 程序瑕疵暂停 ，让GC线程执行的状态

    * 例如，GC期间100毫秒的暂停时间意味着这100毫秒期间内没有应用程序时活动党的。

  * 暂停时间有限，意味着尽可能让单次STW时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5

    <img src="images/313.png" alt="img" style="zoom:67%;" />

---

* 评估GC的性能指标 ：吞吐量 ***vs*** 暂停时间
  * 高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。
  * 低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<font color=blue>**有时候甚至短暂的200毫秒暂停都可能大端终端用户体验**</font>。因此，具有低的暂停时间是非常重要的，特别是对于一个<font color=blue>**交互式应用程序**</font>。
  * 不幸的是“高吞吐量”和“低暂停时间”是一对相互竞争的目标（矛盾）。
    * 因为如果选择吞吐量优先，那么<font color=blue>**必然需要 降低内存的执行频率**</font>，但是这样会导致GC需要更长的暂停时间来执行内存回收。
    * 相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收的暂停时间，也<font color=blue>**只能频繁地执行内存回收**</font>，但这又引起先新生代内训的缩减和导致程序吞吐量的下降。

---

* 在设计（或使用）GC算法时，我们必须确定我们的目标，一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量和最小暂停时间），或尝试找到一个二者的折中方案。
* 现在 标准：<font color=red>**在最大吞吐量优先的情况下，降低停顿时间**</font>。

### 2 不同的垃圾回收器概述

* 垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。<font color=red>**那么，Java常见的垃圾收集器有哪些？**</font>
  * 答：实际上，垃圾收集器适合JVM紧密相连的，不同的厂商，比如Oracle、IBM、RedHat会提供不同版本的JVM，不同版本的JVM会提供不同的垃圾收集器，接下来我介绍一下主流的垃圾收集器：......。

---

* 垃圾收集器发展史

  有了虚拟机，就一定需要垃圾收集的机制，这就是F=Garbage Collection，对应的产品我们称为Garbage Collector。

  * 1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本。

  * 2002年2月26日，Parallel GC（Parallel Scavenge）和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布

  * Parallel GC在JDK6之后称为Hotspot默认GC。

  * 2012年，在JDK1.7u4版本中，G1可用。

  * 2017年，JDK9中G1编程了默认的垃圾收集器，以替代CMS。

  * 2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。

    ---

  * 2018年9月，JDK11发布。引入Epsilon垃圾回收器，又被称为“No-Op（误操作）”收集器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）。

  * 2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：地停顿时间的GC（Experimental）。

  * 2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。

  * 2020年3月，JDK14发布。删除CMS垃圾收集器。扩展ZGC在macOS和Windows上的应用。

* 截止2018年3月（包含），一共发布了7中经典的垃圾收集器

  * 串行回收器：Serial、Serial Old
  * 并行回收器：ParNew、Parallel Scavenge、Parallel Old
  * 并发收集器：CMS、G1

  <img src="images/314.png" alt="img" style="zoom:67%;" />

---

* 经典的垃圾收集器

  * 官方文档：https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf

  <img src="images/315.png" alt="img" style="zoom:100%;" />

---

* 7款经典垃圾收集器与垃圾分带的关系

  <img src="images/316.png" alt="img" style="zoom:67%;" />

---

* 垃圾回收器的组合关系

  <img src="images/317.png" alt="img" style="zoom:67%;" />

  该图已经更新到JKD14

  * 如果把图中的虚线均看做实线，这是JDK8（不包含JDK8）之前垃圾收集器的组合关系
  * 对CMS和MSC之间的线是指如果CMS失败，启动MSC（MSC相当于后备方案）
  * 在JDK8中废弃了两条<font color=red>**红色虚线**</font>的组合（JEP 173），在JDK9中这两根红色虚线做了移除（JEP 214）。
  * 在JDK14中，弃用了<font color=gree>**绿色虚线**</font>的组合（JEP 366）。
  * 在JDK14中，删除了<font color=cyan>**青色虚线框**</font>中的CMS垃圾回收器（JEP 363）。

* JDK8中默认的垃圾回收器是：Parallel Scavenge GC + Parallel Old GC

* 为什么Parallel Scanvenge GC不能和CMS搭配使用？

  * Parallel Scanvenge GC底层用的框架和其他不同，不兼容。

---

* 为什么要这么多垃圾收集器，一个不够吗？
  * 因为Java的使用场景很多，移动端、服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。
* 虽然我们会对各种收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适合的完美收集器存在，更加诶呦万能的收集器。所以<font color=blue>**我们选择的知识对具体应用最适合的收集器**</font>。

---

* 如何查看默认的垃圾收集器

  * <font color=blue>**-XX:PrintCommandLineFlags**</font>：查看命令行相关参数（包含使用的垃圾收集器）

  * 使用命令行指令：<font color=blue>**jinfo -flag 相关垃圾回收参数 进程PID**</font>

  * 代码演示

    ```java
    /**
     *  -XX:+PrintCommandLineFlags
     *
     *  -XX:+UseSerialGC:表明新生代使用Serial GC ，同时老年代使用Serial Old GC
     *
     *  -XX:+UseParNewGC：标明新生代使用ParNew GC
     *
     * JDK8默认使用的GC：
     *  -XX:+UseParallelGC:表明新生代使用Parallel GC
     *  -XX:+UseParallelOldGC : 表明老年代使用 Parallel Old GC
     *  说明：二者可以相互激活
     *
     *  JDK9默认GC：
     *  -XX:+UseG1GC
     *
     *  -XX:+UseConcMarkSweepGC：表明老年代使用CMS GC。同时，年轻代会触发对ParNew 的使用
     */
    public class GCUseTest {
        public static void main(String[] args) {
            ArrayList<byte[]> list = new ArrayList<>();
    
            while(true){
                byte[] arr = new byte[100];
                list.add(arr);
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    ```

    JDK8：

    <img src="images/318.png" alt="img" style="zoom:100%;" />

### 3 Serial回收器：串行回收

* Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。
* Serial收集器作为Hotspot中Client模式下的默认新生代垃圾收集器。
* <font color=blue>**Serial收集器采用复制算法、串行回收和“Stop the world”机制的方式执行内存回收**</font>。
* 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。<font color=blue>**Serial Old收集器同样采用了串行回收和“Stop the world”机制，只不过内存回收算法使用了标记-压缩算法**</font>。
  * Serial Old是运行在Client模式下默认的老年代的垃圾收集器。
  * Serial Old在Server模式下主要有两个用途：①与新生代的Parallel Scavenge配合使用； ②作为老年代CMS收集器的后备垃圾收集方案

---

<img src="images/319.png" alt="img" style="zoom:67%;" />

* 这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它<font color=blue>**只使用一个CPU或一条收集线程去完成垃圾收集工作**</font>，更重要的是在它进行垃圾收集时，<font color=blue>**必须暂停其他所有的工作线程**</font>，直到它收集结束（Stop the world）。

---

* 优势：<font color=blue>**简单而高效**</font>（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。
  * 运行在Client模式下的虚拟机是个不错的选择。
* 在用户的桌面应用场景中，可用内存一般不打（几十MB至一两百MB），可以在较短的时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生GC，使用串行回收器是可以接受的。
* 在Hotspot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都是用串行收集器。
  * 等价于新生代用Serial GC，且老年代用Serial Old GC
  * 注意没有参数：-XX:+UseSerialOldGC

---

* 总结
  * 这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核CPU才可以用。现在都不是单核的了。
  * 对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。

### 4 ParNew回收器：并行回收

* 如果说Serial GC是新生代中单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。
  * Par是Parallel的缩写，New：只能处理的是新生代
* ParNew收集器除了采用<font color=blue>**并行回收**</font>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在新生代中同样采用<font color=blue>**复制算法、“Stop the world”**</font>机制。
* ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器。

---

<img src="images/320.png" alt="img" style="zoom:67%;" />

* 对于新生代，回收次数频繁，使用并行方式高效
* 对于老年代，回收次数较少，使用串行方式节省资源（CPU并行切换线程，串行可以省去切换线程的资源）

---

* 由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效呢？
  * PaeNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以快速地完成垃圾收集，提升程序的吞吐量。
  * 但是在<font color=blue>**单个CPU的环境下，ParNew收集器不比Serial收集器更高效**</font>。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。
* 除Serial外，目前只有ParNew GC能与CMS收集器配合工作。

---

* 在程序中，开发人员可以通过选项“-XX:UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示新生代使用并行收集器，不影响老年代。
* -XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的数。

### 5 Parallel回收器：吞吐量优先

* Hotspot的新生代中除了拥有ParNew收集器是基于并行回收以外，Parallel Scavenge收集器同样采用了<font color=blue>**复制算法、并行回收和“Stop the World”机制**</font>。

* 那么Parallel收集器的出现是否多此一举呢？

  * 和ParNew收集器不同，Parllel Scavenge收集器的目标则是达到一个<font color=blue>**可控的吞吐量**</font>（Throughtput），它也被称为吞吐量优先的垃圾收集器。
  * 自适应调节策略也是Parallel Scavenge与Parallel Scavenge与ParNew的一个重要区别。

* 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要<font color=blue>**适合在后台运算而不需要太多交互的任务**</font>。因此，常见在服务器环境中使用。<font color=blue>**例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序**</font>。

* Parallel收集器在JDK1.6提供了用于执行老年代垃圾收集器的Parallel Old收集器，用来替代老年代的Serial Old收集器。

* Parallel Old收集器采用了<font color=blue>**标记-压缩算法**</font>，但同样也是基于<font color=blue>**并行回收和"Stop the World"机制**</font>。

  <img src="images/321.png" alt="img" style="zoom:67%;" />

* 在程序吞吐量优先的应用场景下，Parallel和Parallel Old收集器的组合，在Server模式下的内存回收性能不错。

* 在Java8中，默认是此垃圾回收器。

---

* 参数配置
  * <font color=blue>**-XX:+UseParallelGC**</font>  手动指定新生代用Parallel并行收集器执行内存回收任务。
  * <font color=blue>**-XX:UseParallelOldGC**</font>  手动指定老年代使用并行会收收集器。
    *  分别适用于新生代和老年代，默认jdk8是开启的。
    *  上面两个参数，默认开启一个，另一个也会被开启。（相互激活）
  * <font color=blue>**-XX:ParallelGCThreads**</font>  设置新生代并行收集器的线程数，一般的，最好与CPU数量相等，以避免过多的线程影响垃圾收集的性能。
    * 默认情况下，当CPU数量小于等于8个，ParallelGCThreads的值等于CPU数量。
    * 当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_count/8]。
  * <font color=blue>**-XX:MaxGCPauseMillis**</font>  设计垃圾收集器的最大停顿时间（即STW的时间）。单位是毫秒。
    * 为了尽可能把停顿时间控制在MaxGCPauseMillis以内，收集器在工作时会调整Java堆大小或者其他一些参数。
    * 对于用户来说，停顿时间越短体验越好，但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。
    * <font color=red>**该参数使用需谨慎。**</font>
  * <font color=blue>**-XX:GCTimeRatio**</font>  垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。
    * 取值范围（0，100）。默认99，也就是垃圾回收时间不超过1%。
    * 与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越短，Ratio参数就越容易超过设定的比例。
  * <font color=blue>**-XX:+UseAdaptiveSizePolicy**</font>  设置Parallel Scavenge收集器具有**自适应调节策略**。
    * 在这种模式下，新生代的大小，Eden和Survivor的比例，晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。
    * 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。

### 6 CMS回收器：低延迟

* 在JDK1.5时期，Hotspot推出了一款在<font color=blue>**强交互应用中**</font>几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<font color=blue>**这款收集器是Hotspot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作**</font>。
* CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延时）就越适合与用户交互的程序，良好的相应速度能提升用户体验。
  * <font color=blue>**目前很大一部分Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短**</font>，以给用户带来较好的体验。CMS收集器就非常符合这类应用需求。
* CMS的垃圾收集器算法采用<font color=blue>**标记-清除**</font>算法，并且也会“Stop the World”。
* 不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。
* 在G1出现之前，CMS使用还是非常广泛的。直到今天，仍有很多系统使用CMS GC。

---

<img src="images/322.png" alt="img" style="zoom:67%;" />

* CMS整个过程比之前的收集器更复杂，整个过程分为4个主要阶段，及初始标记阶段、并发标记阶段、重新标记阶段和并发清楚阶段。
  * 初始标记（Initial-Mark）阶段：在这个阶段中，重新中的所有工作线程都将会因为“Stop the World”机制而出现短暂的暂停，这个阶段的主要任务<font color=red>**仅仅是标记出GC Roots能直接关联到的对象**</font>。一旦标记完成之后就恢复之前被暂停的所有应用线程，由于直接关联对象比较少，所以这里的<font color=red>**速度非常快**</font>。
  * 并发标记（Concurrent-Mark）阶段：从GC Roots的<font color=red>**直接关联对象开始遍历整个对象图的过程**</font>，这个过程<font color=red>**耗时较长**</font>但是<font color=red>**不需要停顿用户线程**</font>，可以与垃圾收集线程一起并发运行。
  * 重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程和垃圾收集线程同时运行或者交叉运行，因此<font color=red>**为了修正并发期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录**</font>，这个阶段的停顿时间通常比初始标记阶段稍长一些，但也远比并发标记阶段时间短。
  * 并发清除（Concurrent-Sweep）阶段：此阶段<font color=red>**清理删除掉标记阶段判断的已经死亡的对象，释放内存空间**</font>。由于不需要移动存活对象，所以这个阶段也可以与用户线程同时并发的

---

* 尽管CMS收集器采用的是并发回收（非独占式），但是在其<font color=blue>**初始标记和重新标记着两个阶段仍然需要执行“Stop the World”机制**</font>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾回收器都做不到完全不需要"Stop the World"，只是尽可能地缩短暂停时间。
* <font color=blue>**由于最耗费时间的并发标记和并发清除阶段都不需要暂停工作，所以整体的回收还是低停顿的**</font>。
* 另外，由于在垃圾收集阶段用户线程并没有中断，所以<font color=blue>**在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用**</font>。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<font color=blue>**当堆内存使用率达到某一阈值时，便开始进行回收**</font>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次<font color=blue>**""Concurrent Mode Failure""**</font>失败，这时虚拟机将启动后备与预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。

---

* CMS收集器的垃圾收集算法采用的是<font color=blue>**标记-清除算法**</font>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将<font color=blue>**会产生一些内存碎片**</font>。那CMS再为新对象分配内存空间时，将无法使用内存碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。

<img src="images/323.png" alt="img" style="zoom:67%;" />

---

* **有人会觉得既然CMS使用Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢?**
  * 答案其实很简单，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢?要保证用户线程还能继续执行，前提是它运行所需的资源不受影响。Mark Compact更适合“Stop the World”这种场景下使用。

* CMS的优点:
  * 并发收集
  * 低延迟

* CMS弊端:
  （1）<font color=blue>**会产生内存碎片**</font>。导致并发清除后，用户线程可用的空间不足。在无法给大对象分配内存的情况下，不得不提前触发Full GC。
  （2）<font color=blue>**CMS收集器对CPU资源非常敏感**</font>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会变低。
  （3）<font color=blue>**CMS收集器无法处理浮动垃圾**</font>。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾线程是同时运行或者交叉运行的，那么<font color=blue>**在并发标记阶段如果产生新的垃圾，CMS将无法对这些垃圾进行标记，最终会导致这些新产生的垃圾对象没有被及时回收**</font>，从而只能再下一次执行GC时释放这些这些之前未被回收的内存空间。

---

* <font color=blue>**-XX:UseConcMarkSweepGC**</font>  手动指定使用CMS收集器执行内存回收任务。
  * 开启该参数后会自动将-XX:+UseParNewGC打开。即ParNew（Young区用）+CMS（Old区用）+Serial Old的组合。
* <font color=blue>**-XX:CMSInitiatingOccupanyFraction**</font>  设置堆内存使用率的阈值，一旦达到阈值，便开始回收。
  * JDK5及以前的版本的默认值为68，即当老年代的利用率达到68%时，会执行一次CMS回收。<font color=blue>**JDK6及以上版本默认值为92%**</font>。
  * 如果内存增长缓慢，这可以设置一个较大的值，大的阈值可以有效降低CMS的出发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此<font color=blue>**通过该选项可以有效降低Full GC的执行次数**</font>。
* <font color=blue>**-XX:UseCMSCompactAtFullCollection**</font>  用于指定在执行完Full GC后对内存进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。
* <font color=blue>**-XX:CMSFullGCsBeforeCompaction**</font>  设置在执行多少次Full GC后对内存空间进行压缩整理。
* <font color=blue>**-XX:ParallelCMSThreads**</font>  设置CMS的线程数量。
  * CMS默认启用的线程数是（ParallelGCThreads+3）/4，ParallelGCThreads是新生代并行收集器的线程数，当CPU资源比较紧张时，收到CMS收集器的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。

---

* 小结：Hotspot有这么多垃圾回收器，那么如果有人问:Serial GC、Parallel GC、CMS GC这三个GC有什不同呢?
  请记住以下口令:

  * 如果你想要最小化地使用内存和并行开销，请选择Serial GC；
  * 如果你想要最大化应用程序的吞吐量，请选择Parallel GC；
  * 如果你想最小化GC的停顿时间，请选择CMS GC。

* JDK9新特性：CMS被标记为Deprecate了（JEP291）

  * 如果对JDK9及以上版本的Hotspot虚拟机使用参数-XX:+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。

* JDK14新特性：删除CMS垃圾回收器（JEP363）

  * 移除CMS垃圾回收器，如果在JDK14中使用-XX:+UseConcMarkSweepGC来开启CMS收集器的话，JVM不会报错，只是给出一个waring信息，但是不会exit。JVM回自动退以默认GC方式启动JVM。

    ```
    Open JDK 64-Bits Server VM waring：Ignoring option UseConcSweepGC;support was removed in 14.0 and the VM will continue execution using default collector.
    ```

### 7 G1回收器：区域化分代式

* 既然我们已经有了前面几个强大的GC，为什么我们还要发布Garbage First（G1） GC？
  * 简单来说，人类的追求是无限的。
  * 原因就在于应用程序所应对的<font color=blue>**业务越来越庞大、复杂，用户越来越多**</font>，没有GC就不能保证应用程序正常运行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC的优化。G1（Garbage-First）垃圾回收器是在Java 7 update 4之后引入的一个新的垃圾回收器。是当今回收器技术发展的最前沿成果之一。
  * 与此同时，为了适应现在<font color=blue>**不断扩大的内存和不断增加的处理器数量**</font>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。
  * 官方给G1设定的目标是：<font color=blue>**在延迟可控的情况下 获得尽可能高的吞吐量**</font>，所以G1才担当起“全功能收集器”的重任与期望。
* 为什么名字叫做Garbage First（G1）呢？
  * 因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续）。使用不同的Region表示Eden、幸存者0区、幸存者1区、老年代等。
  * G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要的经验值），在后台维护一个优先列表，<font color=blue>**每次根据允许的收集时间，优先回收价值最大的Region**</font>。
  * 由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）.

---

* G1（Garbage First）是一款面向服务端应用的垃圾回收器，<font color=blue>**主要是针对配对多核CPU及大容量内存的机器**</font>，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。
* 在JDK1.7版本正式启用，移除了Experimental的标识，<font color=blue>**是JDK9以后的默认垃圾回收器**</font>，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为“<font color=blue>**全功能的垃圾收集器**</font>”。
* 与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中G1还不是默认的垃圾回收器，需要使用-XX:+UseG1GC来启用。

---

* G1回收器的特点（优势）

  * <font color=blue>**并行与并发**</font>

    * 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW。
    * 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。

  * <font color=blue>**分带收集**</font>

    * 从分代上看，<font color=blue>**G1依然属于分代型垃圾回收器**</font>，它会区分新生代和老年代，新生代依然有Eden区和Survivor区，但从堆的结构看，它不要求整个Eden区、新生代或者老年代都是连续的，也不再坚持固定大小和固定数量。
    * 将<font color=blue>**堆空间分为若干区域（Region），这些区域中包含了逻辑上的新生代和老年代**</font>。
    * 和之前的各类回收器不同，它同时<font color=blue>**兼顾新生代和老年代**</font>。对比其他回收器，或者工作在新生代，或者工作在老年代。

    <img src="images/324.png" alt="img" style="zoom:67%;" />

    <img src="images/325.png" alt="img" style="zoom:67%;" />

  * <font color=blue>**空间整合**</font>

    * CMS：“标记-清除”算法、内存碎片，若干次GC后进行一次碎片整理。
    * G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。<font color=blue>**Region之间是复制算法**</font>。但整体上实际可看做是<font color=blue>**标记-压缩（Mark-Compact）算法**</font>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。

  * <font color=blue>**可预测的停顿时间模型**</font>（即：软实时soft real-time）

    这是G1相对于CMS的另一大优势，G1除了追求低停外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的片段，消耗在垃圾收集上的时间不得超过N毫秒。

    * 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，由于对于全局停顿情况的发生也能得到很好的控制。
    * G1跟踪各个Region里面的垃圾堆积的价值（回收所获得的的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<font color=blue>**每次根据允许的收集时间，优先回收价值最大的Region**</font>。保证G1收集器在有限的时间内可以<font color=blue>**获取尽可能高的收集效率**</font>。
    * 相比于CMS，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好的多。

* G1的缺点

  * 相较于CMS，G1还不具备全方位，压倒性优势。比如在用户程序运行过程中，G1无论为了垃圾收集产生的内存占用（Footprint，一般来说比CMS多10%~20%）还是程序运行时的额外执行负载（Overload）都要比CMS高。
  * 从经验上来说，在小内存应用CMS的表现大概率优于G1，而G1在大内存应用上则发挥其优势，平衡点在6-8GB。

---

* G1回收器参数设置

  * <font color=blue>**-XX:UseG1GC**</font>    手动指定使用G1收集器执行内存回收任务。
  * <font color=blue>**-XX:G1HeapRegionSize**</font>    设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出2048个区域。Region默认是堆内存的1/2000。
  * <font color=blue>**-XX:MaxGCPauseMillis**</font>    设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认是200ms。
  * <font color=blue>**-XX:ParallelGCThread**</font>    设置STW时GC线程数的值。最多设置为8。
  * <font color=blue>**-XX:ConcGCThreads**</font>    设置并发标记的线程数，建议将该参数设置为并行垃圾回收线程（ParallelGCThreads）的1/4左右。
  * <font color=blue>**-XX:InitiatingHeapOccupancyPercent**</font>    设置触发并发GC周期的Java堆占用阈值。超过此值，就触发GC。默认是45.

* G1回收器的常见操作步骤：G1的设计原则就是简化JVM性能调优：

  * 第一步：开启G1垃圾收集器
  * 第二步：设置堆的最大内存
  * 第三步：设置最大停顿时间

  G1中提供了三种垃圾回收模式：Young GC、Mixed GC和Full GC，在不同的条件下触发

---

* G1回收器的使用场景

  * 面向服务器端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）

  * 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案：

    * 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部Region的增量式清理来保证每次GC停顿时间不会过长）。

  * 用来替换掉JDK1.5中的CMS收集器（在下面的情况时，使用G1可能比CMS好）：

    ① 超过50%的Java堆被活动数据占用；

    ② 对象分配频率或年代提升频率变化很大；

    ③ GC停顿时间过长（长于0.5至1秒）。

  * Hotspot垃圾收集器里，除G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的都线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。

---

* 分区Region：化整为零

  * 使用G1收集器时，它将整个Java堆划分为越2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过-XX:G1HeapRegionSize设定。<font color=blue>**所有Region大小相同，且在JVM生命周期内不会被改变**</font>。
  * 虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。

  ---

  <img src="images/326.png" alt="img" style="zoom:67%;" />

  * 一个region有可能属于Eden，Survivor或者Old/Tenured内存区域，但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old区域区域，图中空白的表示未使用的内存空间。

  * G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超高1.5个region，就放到H。

  * 设置H的原因：

    * 对于堆中的大对象，默认直接分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。<font color=blue>**如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储**</font>。为了能找到连续的H去，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。

  * Bump the pointer（指针碰撞） / TLAB

    <img src="images/327.png" alt="img" style="zoom:67%;" />

---

* G1回收器垃圾回收过程：G1 GC的垃圾回收主要包括如下三个环节：

  * 新生代GC（Young GC）
  * 老年代并发标记过程（Coucurrent Marking）
  * 混合回收（Mixed GC）
  * （如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）

  ---

  <img src="images/328.png" alt="img" style="zoom:67%;" />

  * 顺时针，young gc -> young gc + concurrent mark -> Mixed GC顺序，进行垃圾回收。

* G1回收器垃圾回收过程

  * 应用程序分配内存，<font color=blue>**当新生代的Eden区用尽时开始新生代回收过程；**</font>G1的新生代收集阶段是一个<font color=blue>**并行的独占式收集器**</font>。在新生代回收期间，G1 GC暂停所有应用程序线程，启动多线程执行新生代回收。然后<font color=blue>**从新生代区间移动存活对象到Survivor区间或者老年区间，也可能是两个区间都会涉及**</font>。
  * 当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。
  * 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和新生代不同，老年代的G1回收器和其他GC不同，<font color=blue>**G1的老年代回收期不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了**</font>。同时，这个老年代Region是和新生代仪器被回收的。
  * 举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟相应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次新生代回收，每31个小时整个堆的使用率会达到45%，会开始老年代的并发标记过程，标记完成后开始四到五次的混合回收。

---

* G1回收器垃圾回收过程：Remembered Set（RSet）

  * 一个对象被不同区域引用的问题

  * 一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活，是否需要扫描整个Java堆才能保证准确？

  * 在其他的分代收集器，也存在这个问题（而G1更突出）

  * 回收新生代也不得不同时臊面老年代？

  * 这样的话会降低Minor GC的效率；

  * <font color=red>**解决方法：**</font>

    * 无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描；
    * <font color=blue>**每个Region都有一个对应的Remembered Set**</font>；
    * 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；
    * 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；
    * 如果不同，通过CardTable把相关引用信息记录到引用指向对象所在的Region对应的Remembered Set中；
    * 当进行垃圾回收时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。

    <img src="images/329.png" alt="img" style="zoom:67%;" />

---

G1回收详细过程：

* G1回收过程一：新生代GC

  * JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次新生代垃圾回收过程。
  * <font color=blue>**新生代垃圾回收只回收Eden区和Survivor区**</font>。
  * YGC时，首先G1停止应用程序的执行（Stop The World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，新生代回收过程包含新生代Eden区和Survivor区所有的内存分段。

  <img src="images/330.png" alt="img" style="zoom:67%;" />

  * 然后开始如下回收过程：

    * <font color=red>**第一阶段：扫描根。**</font>

      根是指static变量执行的对象，正在执行的方法调用链上的全局变量等。根引用连通RSet记录的外部引用作为扫描存活对象的入口。

    * <font color=red>**第二阶段：更新RSet。**</font>

      处理dirty card queue中的card，更新Rset。此阶段完成后，<font color=blue>**RSet可以准确的反应老年代对所在内存分段中对象的引用。**</font>

      * dirty card queue

        对于应用程序的赋值语句object1.field = object2，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在新生代回收的时候，G1会对dirty card queue中的card进行处理，以更新RSet，保证RSet实时准确的反应引用关系。

        那为什么不在赋值语句处直接更新Rset呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。

    * <font color=red>**第三阶段：处理RSet。**</font>

      识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是是存活的对象。

    * <font color=red>**第四阶段：复制对象。**</font>

      此阶段，对象树被遍历，Eden区内存段中存活的对象会被赋值到Survivor区中的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阈值会被赋值到Old区中空的内存分段。如果Survivor恐案件不够，Eden空间的部分数据会直接晋升到老年代空间。

    * <font color=red>**第五阶段：处理引用。**</font>

      处理Soft，Weak，Phantm，Final，JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。

* G1回收过程二：并发标记过程

  * <font color=red>**1.初始标记阶段：**</font>标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次新生代GC。
  * <font color=red>**2.根区域扫描（Root Region Scanning）：**</font>G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。
  * <font color=red>**3.并发标记（Concurrent Marking）：**</font>在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记阶段，<font color=blue>**若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。**</font>同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。
  * <font color=red>**4.再次标记：**</font>由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。
  * <font color=red>**5.独占清理：**</font>计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。
    * 这个阶段并不会实际上去做垃圾的收集
  * <font color=red>**6.并发清理：**</font>识别并清理完全空闲的区域。

* G1回收过程三：混合回收

  <img src="images/331.png" alt="img" style="zoom:67%;" />

  * 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存你分段被计算了出来。默认情况下，这些老年代的内存会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收。
  * 混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和新生代回收的算法完全一致，只是回收集多了老年代的内存分段。具体过程请参考上面的新生代回收过程。
  * 由于老年代的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。<font color=blue>**垃圾占内存分段比例越高的，越会被先回收**</font>。并且有一个阈值会决定内存分段是否被回收，-XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活对象占比高，在复制的时候会花费更多的时间。
  * 混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认为10%，意思是允许整个堆内存中有10%的空间浪费，意味着如果发现可以回收的垃圾占内存的比例低于10%，则不再进行混合回收。因为GC会花费很富哦的时间但是回收的内存却很少。

* G1回收可选的过程四：Full GC

  * G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会<font color=blue>**会停止应用程序的执行**</font>（Stop The World），使用<font color=blue>**单线程**</font>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。
  * 要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如<font color=blue>**堆内存太小**</font>，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。
  * 导致G1 Full GC的原因可能有两个：
    * Evacuation（回收）的时候没有足够的to-space来存放晋升的对象；
    * 并发处理过完成之前空间耗尽。

---

* G1回收过程：补充
  * 从Oracle官方透露出来的嘻嘻可获知，回收阶段（Evacuation）其实也有相关设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1知识回收一部分Region，停顿时间是用户可控的，所以并不迫切去实现，而<font color=blue>**选择把这个特性放到了G1之后的低延迟垃圾收集器（即ZGC）中**</font>。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。

* G1回收器优化建议
  * 新生代大小
    * 避免使用-Xmn或-XX:NewRatio等相关选项显式设置新生代大小
    * 固定新生代的大小会覆盖咋听时间目标
  * 暂停时间目标不要太过严苛
    * G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间。
    * 评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿承受更多的垃圾回收开销（因为回收频率增加），而这些会直接影响到吞吐量。

### 8 垃圾回收器总结

* 截止JDK 1.8，一共有7款不同的垃圾回收器。每一款不同的垃圾回收器都有不同的特点，在具体使用的时候，需要根据具体情况选用不同的垃圾收集器。

  <img src="images/332.png" alt="img" style="zoom:67%;" />

* GC发展阶段：

  Serial -> Parallel（并行） -> CMS（并发） -> G1 -> ZGC

* 怎么选择垃圾回收器？

  Java垃圾回收器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾回收器可以让JVM的性能有一个很大的提升。

  1. 优先调整堆的大小让JVM自适应完成
  2. 如果内存小于100MB，使用串行收集器
  3. 如果单核、单机程序，并且没有停顿时间的要求，串行收集器
  4. 如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自行选择
  5. 如果是多CPU、追求地停顿时间，需要快速响应（比如延迟不能超高1秒，如互联网应用），使用并发收集器；官方推荐G1，性能高。<font color=blue>**现在互联网的项目，基本都是使用G1**</font>。

  * **最后明确一个观点**
    * 没有最好的收集器，更没有万能的收集器；调优永远针对特定场景、特定需求，不存在一劳永逸的收集器。

---

* 面试
  * 对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂原理，一定会成为面试中的加分项。这里比较通用、基础的部分如下：
    * 垃圾收集的短发有哪些？如何判断一个对象是否可以回收？
    * 垃圾收集器工作的基本流程。
  * 另外，大家需要关注垃圾收集器这一章的各种常用的参数。

### 9 GC日志分析

<img src="images/333.png" alt="img" style="zoom:67%;" />

<img src="images/334.png" alt="img" style="zoom:67%;" />

<img src="images/335.png" alt="img" style="zoom:67%;" />

<img src="images/336.png" alt="img" style="zoom:67%;" />

<img src="images/337.png" alt="img" style="zoom:67%;" />

<img src="images/338.png" alt="img" style="zoom:67%;" />

<img src="images/339.png" alt="img" style="zoom:67%;" />

<img src="images/340.png" alt="img" style="zoom:67%;" />

<img src="images/341.png" alt="img" style="zoom:95%;" />

<img src="images/342.png" alt="img" style="zoom:95%;" />

---

```java
/**
 * 在jdk7 和 jdk8 中分别执行
 * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC
 */
public class GCLogTest1 {
    private static final int _1MB = 1024 * 1024;

    public static void testAllocation() {
        byte[] allocation1, allocation2, allocation3, allocation4;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        allocation4 = new byte[4 * _1MB];
    }

    public static void main(String[] agrs) {
        testAllocation();
    }
}
```

<img src="images/343.png" alt="img" style="zoom:67%;" />

* jdk7 和 jdk8 分配策略一致

<img src="images/344.png" alt="img" style="zoom:67%;" />

<img src="images/345.png" alt="img" style="zoom:67%;" />

<img src="images/346.png" alt="img" style="zoom:67%;" />

---

* GC日志分析工具：可以使用一些工具去分析这些gc日志。

  * 常见的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等。

  * GCViewer

    <img src="images/347.png" alt="img" style="zoom:67%;" />

  * GCEasy

    https://gceasy.io/

### 10 垃圾回收器的新发展

* GC仍然处于飞速发展之中，目前默认选项<font color=blue>**G1 GC在不断的进行改进**</font>，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK 10以后，Full GC已经是并行运行，在很多场景下，其表现还略优于Parallel GC的并行Full GC实现。
* 即使是Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<font color=blue>**在Serverless等新的应用场景下，Serial GC找到了新的舞台**</font>。
* 比较不行的是CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中被移除。

---

* JDK11新特性

  <img src="images/348.png" alt="img" style="zoom:67%;" />

* Open JDK12的Shenandoah GC

  * 现在G1回收器已经成为默认回收器好几年了。
  * 我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和shenandoah（Open JDK12）。两款GC的主打特点都是<font color=blue>**低停顿**</font>。

  <img src="images/349.png" alt="img" style="zoom:67%;" />

  <img src="images/350.png" alt="img" style="zoom:67%;" />

  <img src="images/351.png" alt="img" style="zoom:67%;" />

---

* 令人震惊、革命性的ZGC

  https://docs.oracle.com/en/java/javase/12/gctuning/

  <img src="images/352.png" alt="img" style="zoom:67%;" />

  <img src="images/353.png" alt="img" style="zoom:67%;" />

  <img src="images/354.png" alt="img" style="zoom:67%;" />

  <img src="images/355.png" alt="img" style="zoom:67%;" />

  <img src="images/356.png" alt="img" style="zoom:67%;" />

  <img src="images/357.png" alt="img" style="zoom:67%;" />

  <img src="images/358.png" alt="img" style="zoom:67%;" />

  <img src="images/359.png" alt="img" style="zoom:67%;" />

  <img src="images/360.png" alt="img" style="zoom:67%;" />

---

* 最后寄语

  <img src="images/361.png" alt="img" style="zoom:67%;" />

  <img src="images/362.png" alt="img" style="zoom:67%;" />