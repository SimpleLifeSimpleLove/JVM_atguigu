# 第19章 字节码指令集与解析举例

## 1 概述

* Java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令。
* Java虚拟机的指令由<font color=red>**一个字节长度**</font>的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。由于Java虚拟机采用面向操作数栈而不是寄存器结构，所以大多数指令都不包含操作数，只有一个操作码。
* 由于限制了Java虚拟机操作码的长度为一个字节（即0~255），这意味着指令集的操作码总数不会超过256条。
* 官方文档：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html
* 熟悉虚拟机的指令对于动态字节码生成、反编译Class文件、Class文件修补都有着非常重要的价值。因此，阅读字节码作为了解Java虚拟机的基础操作，需要熟练掌握常见指令。

---

* 执行模型

  如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面的伪代码当做最基本的执行模型来理解。

  ```
  do {
  	自动计算PC寄存器的值加1;
  	根据PC寄存器的指示位置，从字节码流中取出操作数;
  	if (字节码存在操作数)
  		从字节码流中取出操作数;
  	执行操作码所定义的操作;
  } while(字节码长度 > 0);
  ```

---

* 字节码与数据类型

  在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload指令用于从局部变量表中加载int类型的数据到操作数栈中，而fload指令加载的则是float类型数据。

  * 对于大部分与数据类型相关的字节码指令，<font color=red>**它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务**</font>：
    * i 代表对int类型数据操作
    * l 代表 long
    * s 代表 short
    * b 代表 byte
    * c 代表 char
    * f 代表 float
    * d 代表 double
  * 也有一些指令的助记符中<font color=red>**没有明确地指明操作类型的字母**</font>，例如arraylength指令，它没有代表数据类型的特殊字符，但是操作数永远只能是一个数组类型的对象。
  * 还有另外一些指令，如无条件跳转goto，则是与<font color=red>**数据类型无关的**</font>。
  * 大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作。

---

* 指令分类
  * 由于完全介绍和学习这些指令需要花费大量时间。为了让大家能够更快地熟悉和了解这些基本指令，这里将JVM中的字节码指令按照用途大致分为 9 类。
    * 加载与存储指令
    * 算数指令
    * 类型转换指令
    * 对象的创建与访问指令
    * 方法调用与返回指令
    * 操作数栈管理指令
    * 比较控制指令
    * 异常处理指令
    * 同步控制指令
  * （说在前面）在做值相关操作时：
    * 一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等获得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈。
    * 一个指令，也可以从操作数栈中取出一到多个值（pop多次），完成赋值、加减乘除、方法传参、系统调用等操作。

## 2 加载与存储指令

* 作用：加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递。
* 常用指令
  * 局部变量表压栈指令：将一个局部变量加载到操作数栈：xload、xload_\<n>（其中 x 为 i、l、f、d、a，n 为 0 到 3）
  * 常量入栈指令：将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_\<i>、lconst\_\<l>、fconst\_\<f>、dconst\_\<d>
  * 出栈装入局部变量表指令：将一个数值从操作数栈存储到局部变量表：xstore、xstore_\<n>（其中 x 为 i、l、f、d、a，n 为 0 到 3）；xastore（其中 x 为 i、l、f、d、a、b、c、s）
  * 扩展局部变量表的访问索引的指令：wide
* 上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如 iload_\<n>）。这些指令助记符实际上代表了一组指令（例如 iload\_\<n>代表了iload\_0、iload\_1、iload\_2和iload\_3这几个指令）。这几组指令都是墨盒带有一个操作数的通用指令（例如 iload）的特殊形式，<font color=red>**对于这若干组指令来说，他们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中**</font>。
* 除此之外，他们的语义与原生的通用指令完全一致（例如 iload_0的语义与操作数为 0 时的 iload 指令语义完全一致）。在尖括号之间的字母制定了指令隐含操作数的数据类型，\<n>代表非负的整数，\<i>代表是 int 类型的整数，\<l>代表long类型，\<f>代表float类型，\<d>代表double类型。
* 操作byte、char、short和boolean类型的数据时，经常用 int 类型的指令来表示。

---

* 再谈操作数栈和局部变量表

  <img src="images/21.png" alt="img" style="zoom:75%;" />

  * 操作数栈

    我们知道，Java字节码是Java虚拟机所使用的的指令集。因此，它与Java虚拟机基于栈的计算模型是密不可分的。

    在解释执行过程中，每当为Java方法分配栈帧时，Java虚拟机往往需要开辟一块额外的空间作为<font color=red>**操作数栈，来存放计算操作数以及返回结果**</font>。

    具体来说便是：执行每一条指令之前，Java虚拟机要求该指令的操作数已经被压入操作数栈中。在执行指令时，Java虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。

    <img src="images/22.png" alt="img" style="zoom:75%;" />

    以加法指令 iadd 为例。假设在执行该指令前，栈顶的两个元素分别为 int 值 1 和 int 值 2，那么 iadd 指令将弹出两个 int，并将求得的和 int 值 3 压入栈中。

    <img src="images/23.png" alt="img" style="zoom:75%;" />

  * 局部变量表（Local Variables）

    Java 方法栈帧的另外一个重要组成部分则是局部变量区，<font color=red>**字节码程序可以将计算的结果缓存到局部变量区之中**</font>。

    实际上，Java 虚拟机将局部变量区<font color=red>**当成一个数组**</font>，依次存放 this 指针（非静态方法），所传入的参数，以及字节码中的局部变量。

    和操作数栈一样，long 类型以及 double 类型的值将占据两个单元，其余类型占据一个单元。

    <img src="images/24.png" alt="img" style="zoom:75%;" />

    举例：

    ```java
    public void foo(long l, float f) {
        {
            int i = 0;
        }
        {
            String s = "Hello, World!"
        }
    }
    ```

    对应的图示：

    <img src="images/25.png" alt="img" style="zoom:75%;" />

    在栈帧中，与性能调优最为密切的部分就是局部变量表。局部变量表中的变量也是很重要的垃圾回收根节点，只要被局部变量表中直接或者间接引用的对象都不会被回收。

    在方法执行时，虚拟机使用局部变量表完成方法的传递。

---

* 局部变量表压栈指令

  * <font color=red>**局部变量表压栈指令将给定的局部变量表中的数据压入操作数栈。**</font>

  * 这类指令大体可以分为：（这里，x 的取值表示数据类型）

    * xload_\<n>（x 为 i、l、f、d、a，n 为 0 到 3）
    * xload （x 为 i、l、f、d、a）

  * 指令 xload_n 表示将第 n 个局部变量压入操作数栈，比如iload_1、fload_0、aload_0等指令。其中aload_n 表示将一个对象引用压栈。

  * 指令xload 通过指定参数的形式，把局部变量压入操作栈，当使用这个命令时，表示局部变量可能超过了 4 个，比如指令 iload、fload等。

  * 例子：

    ```java
    //1.局部变量压栈指令
    public void load(int num, Object obj,long count,boolean flag,short[] arr) {
        System.out.println(num);
        System.out.println(obj);
        System.out.println(count);
        System.out.println(flag);
        System.out.println(arr);
    }
    ```

    对应的字节码指令如下：

    ```
     0 getstatic #2 <java/lang/System.out>
     3 iload_1
     4 invokevirtual #3 <java/io/PrintStream.println>
     7 getstatic #2 <java/lang/System.out>
    10 aload_2
    11 invokevirtual #4 <java/io/PrintStream.println>
    14 getstatic #2 <java/lang/System.out>
    17 lload_3
    18 invokevirtual #5 <java/io/PrintStream.println>
    21 getstatic #2 <java/lang/System.out>
    24 iload 5
    26 invokevirtual #6 <java/io/PrintStream.println>
    29 getstatic #2 <java/lang/System.out>
    32 aload 6
    34 invokevirtual #4 <java/io/PrintStream.println>
    37 return
    ```

---

* 常量入栈指令

  * 常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为const系列、push系列和ldc系列。

  * 指令 const 系列：

    对于特定的常量入栈，入栈的常量隐含在指令本身。指令有：iconst_\<i>（i 从-1到5）、lconst\_\<l>（l 从0到 1）、fconst\_\<f>（f 从0到2）、dconst\_\<d>（d 从0到 1）、aconst\_null。比如：

    * iconst\_m1     将-1压入操作数栈；
    * iconst_x（x 为0到5）     将 x 压入栈；
    * lconst_0、lconst_1     分别将长整数 0 和 1 压入栈；
    * fconst_0、fconst_1、fconst_2     分别将浮点数0、1、2压入栈；
    * dconst_0、dconst_1     分别将double型 0 和 1 压入栈；
    * aconst_null     将 null 压入操作数栈；

    从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i 代表整形，l 代表长整形，f 代表浮点数，d 代表双精度浮点，习惯上用 a 表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。

  * 指令push系列：

    主要包括 bipush 和 sipush。他们的区别在于接收数据类型的不同，bipush 接收8位整数作为参数，sipush 接收16位整数，他们都将参数压入栈。

  * 指令ldc系列：

    如果以上指令都不能满足需求，那么可以使用万能的<font color=red>**ldc**</font>指令，它可以接收一个8位的参数，该参数指向常量池中的 int、float或者String的索引，将指定的内容压入堆栈。

    类似的还有<font color=red>**ldc_w**</font>，它接收两个8位参数，能支持的索引范围大于ldc。

    如果要压入的元素是long或者double类型的，则使用<font color=red>**ldc2_w**</font>指令，使用方式是类似的。

    |               类型                | 常数指令 |             范围              |
    | :-------------------------------: | :------: | :---------------------------: |
    | int（boolean, byte, char, short） |  iconst  |            [-1, 5]            |
    |                                   |  bipush  |          [-128, 127]          |
    |                                   |  sipush  |        [-32768, 32767]        |
    |                                   |   ldc    |         any int value         |
    |               long                |  lconst  |             0, 1              |
    |                                   |   ldc    |        any long value         |
    |               float               |  fconst  |            0, 1, 2            |
    |                                   |   ldc    |        any float value        |
    |              double               |  dconst  |             0, 1              |
    |                                   |   ldc    |       any double value        |
    |             reference             |  aconst  |             null              |
    |                                   |   ldc    | String literal, Class literal |

  * 例子：
  
    ```java
    //2.常量入栈指令
    public void pushConstLdc() {
        int i = -1;
        int a = 5;
        int b = 6;
        int c = 127;
        int d = 128;
        int e = 32767;
        int f = 32768;
    }
    ```
  
    对应的字节码指令：
  
    ```
     0 iconst_m1
     1 istore_1
     2 iconst_5
     3 istore_2
     4 bipush 6
     6 istore_3
     7 bipush 127
     9 istore 4
    11 sipush 128
    14 istore 5
    16 sipush 32767
    19 istore 6
    21 ldc #7 <32768>
    23 istore 7
    25 return
    ```
  
    ```java
    public void constLdc() {
        long a1 = 1;
        long a2 = 2;
        float b1 = 2;
        float b2 = 3;
        double c1 = 1;
        double c2 = 2;
        Date d = null;
    }
    ```
  
    对应的字节码指令：
  
    ```
     0 lconst_1
     1 lstore_1
     2 ldc2_w #8 <2>
     5 lstore_3
     6 fconst_2
     7 fstore 5
     9 ldc #10 <3.0>
    11 fstore 6
    13 dconst_1
    14 dstore 7
    16 ldc2_w #11 <2.0>
    19 dstore 9
    21 aconst_null
    22 astore 11
    24 return
    ```

---

* 出栈装入局部变量表指令

  * 出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量表赋值。

  * 这类指令主要以 store 的形式存在，比如 xstore （x 为 i、f、l、d、a）、xstore_n（x 为 i、f、l、d、a，n 为 0到 3）
    * 其中，指令 istore_n 将从操作数栈中弹出一个整数，并把它赋值给局部变量表索引 n的位置。
    * 指令 xstore 由于没有隐含参数信息，故需要提供一个byte参数类型指令目标局部变量表的位置。

  * 说明：
    * <font color=red>**一般来说，类似像store这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。**</font>但是，为了尽可能压缩指令大小，使用专门的 istore_1指令表示将弹出的元素放置在局部变量表的第一个位置。类似的还有 istore_0、istore_2、istore_3，它们分别表示从操作数栈弹出一个元素，存放在局部变量表的第0、2、3个位置。
    * 由于局部变量表的前几个位置总是非常常用，因此<font color=red>**这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积**</font>。如果局部变量表非常大，需要存储的槽位大于 3，那么可以使用istore指令，另外一个参数，用来表示需要存放的槽位位置。

  * 例子：

    ```java
    //3.出栈装入局部变量表指令
    public void store(int k, double d) {
        int m = k + 2;
        long l = 12;
        String str = "atguigu";
        float f = 10.0F;
        d = 10;
    }
    ```

    对应的字节码指令：

    ```
     0 iload_1
     1 iconst_2
     2 iadd
     3 istore 4
     5 ldc2_w #13 <12>
     8 lstore 5
    10 ldc #15 <atguigu>
    12 astore 7
    14 ldc #16 <10.0>
    16 fstore 8
    18 ldc2_w #17 <10.0>
    21 dstore_2
    22 return
    ```

    <img src="images/26.png" alt="img" style="zoom:60%;" />

    ```java
    public void foo(long l, float f) {
        {
            int i = 0;
        }
        {
            String s = "Hello, World";
        }
    }
    ```

    对应的字节码指令：

    ```
    0 iconst_0
    1 istore 4
    3 ldc #19 <Hello, World>
    5 astore 4
    7 return
    ```

## 3 算数指令

* 作用：

  * 算数指令用于对两个操作数栈的数值进行某种特定的运算，并把结果重新压入操作数栈。

* 分类：

  * 大体上算数指令可以分为两种：对<font color=red>**整形数据**</font>进行运算的指令与对<font color=red>**浮点类型数据**</font>进行运算的指令。

* byte、short、char和boolean类型说明

  * 在每一大类中，都有针对Java虚拟机具体数据类型的专用算数指令。但是没有直接支持byte、short、char和boolean类型的算数指令，对于这些数据的运算，都是用 int 类型的指令来处理。此外，在处理byte、short、char和boolean类型的数组时，也会转换为使用对应的 int 类型的字节码指令来处理。

    <img src="images/27.png" alt="img" style="zoom:80%;" />

* 运算时的溢出

  * 数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java虚拟机规范并无明确规定过整形数据溢出的具体结果，仅规定了在处理整形数据时，只有除法指令以及求余指令中当出现除数为 0 时导致虚拟机抛出异常 ArithmeticException。

* 运算模式

  * 向最近接数舍入模式：JVM要求在进行浮点数计算时，所有运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最近接的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；
  * 向零舍入模式：将浮点数转化为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果。

* NaN的使用

  * 当一个操作产生溢出时，将会使用有符号数的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用 NaN值来表示。而且所有使用NaN值作为操作数的算数操作，结果都会返回 NaN。

  * 例子：

    ```java
    @Test
    public void method1(){
        int i = 10;
        double j = i / 0.0;
        System.out.println(j);  // 无穷大
    
    
        double d1 = 0.0;
        double d2 = d1 / 0.0;
        System.out.println(d2);  // NaN: not a number
        
        System.out.println(10 / 0);  // java.lang.ArithmeticException: / by zero
    }
    ```

    结果：		Infinity
    					NaN

---

* 所有的算数指令包括：

  * 加法指令：iadd、ladd、fadd、dadd
  * 减法指令：isub、lsub、fsub、dsub
  * 乘法指令：imul、lmul、fmul、dmul
  * 除法指令：idiv、ldiv、fdiv、ddiv
  * 求余指令：irem、lrem、frem、drem    // remainder：余数
  * 取反指令：ineg、lneg、fneg、dneg    // negation：取反
  * 自增指令：iinc（直接在局部变量表中自增）
  * 位运算指令，又可分为：
    * 位移指令：ishl、ishr、iushr、lshl、lshr、lushr
    * 按位或指令：ior、lor
    * 按位与指令：iand、land
    * 按位异或指令：ixor、lxor
  * 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp

  例子：

  ```java
  public void method2(){
      float i = 10;
      float j = -i;
      i = -j;
  }
  ```

  ```
  0 ldc #5 <10.0>
  2 fstore_1
  3 fload_1
  4 fneg
  5 fstore_2
  6 fload_2
  7 fneg
  8 fstore_1
  9 return
  ```

  

  ```java
  public void method3(int j){
      int i = 100;
      // i = i + 10;
      i += 10;
  }
  ```

  ```
  0 bipush 100
  2 istore_2
  3 iinc 2 by 10
  6 return
  ```

  

  ```java
  public void method3(int j){
      int i = 100;
      i = i + 10;
      // i += 10;
  }
  ```

  ```
  0 bipush 100
  2 istore_2
  3 iload_2
  4 bipush 10
  6 iadd
  7 istore_2
  8 return
  ```

  ```java
  public int method4(){
          int a = 80;
          int b = 7;
          int c = 10;
          return (a + b) * c;
      }
  ```

  ```
   0 bipush 80
   2 istore_1
   3 bipush 7
   5 istore_2
   6 bipush 10
   8 istore_3
   9 iload_1
  10 iload_2
  11 iadd
  12 iload_3
  13 imul
  14 ireturn
  ```

  ```java
  public int method5(int i ,int j){
      return ((i + j - 1) & ~(j - 1));
  }
  ```

  ```
   0 iload_1
   1 iload_2
   2 iadd
   3 iconst_1
   4 isub
   5 iload_2
   6 iconst_1
   7 isub
   8 iconst_m1
   9 ixor
  10 iand
  11 ireturn
  ```

---

* 关于自增操作的说明：

  * 如果不涉及到赋值，只是单纯的 i++ 和 ++i ，从字节码的角度看，完全一样

    ```java
    //关于(前)++和(后)++
    public void method6(){
        int i = 10;
        i++;
        // ++i;
    }
    ```

    ```
    0 bipush 10
    2 istore_1
    3 iinc 1 by 1
    6 return
    ```

  * 如果涉及到赋值， i++ 和 ++i ，从字节码角度看不一样

    ```java
    public void method7(){
        int i = 10;
        int a = i++;
    
        int j = 20;
        int b = ++j;
    }
    ```

    ```
     0 bipush 10
     2 istore_1
     3 iload_1
     4 iinc 1 by 1
     7 istore_2
     8 bipush 20
    10 istore_3
    11 iinc 3 by 1
    14 iload_3
    15 istore 4
    17 return
    
    ```

  * 如下操作，结果？

    ```java
    //思考
    public void method8() {
        int i = 10;
        i = i++;
        System.out.println(i);  // 10
    }
    ```

    ```
     0 bipush 10
     2 istore_1
     3 iload_1
     4 iinc 1 by 1
     7 istore_1
     8 getstatic #2 <java/lang/System.out>
    11 iload_1
    12 invokevirtual #5 <java/io/PrintStream.println>
    15 return
    ```

---

* 比较指令的说明：

  * 比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈。
  * 比较指令有：dcmpg、dcmpl、fcmpg、fcmpl、lcmp
    * 与前面讲解的指令类似，首字符d表示double类型，f表示float，l表示long。
  * 对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg、fcmpl两个指令，他们的区别在于数字比较时，若遇到NaN值，处理结果不同。
  * 指令dcmpg、dcmpl也是类似的，根据其命名可以推断其含义，在此不再赘述。
  * 指令lcmp针对long型整数，由于long型整数没有NaN值，故无需准备两套指令。

  举例：

  * 指令fcmpg、fcmpl都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为 v2，栈顶顺位第2位元素为 v1，若 v1 == v2，则压入0；若v1 > v2，则压入1；若v1 < v2，则压入-1。
  * 两个指令的区别之处在于，当遇到NaN值，fcmpg会压入 1， 而fcmpl 会压入 -1。



## 4 类型转换指令

* 说明

  * 类型转化指令可以将两种不同的数值类型进行相互转换
  * 这些转换操作一般用于实现用户代码的<font color=red>**显式类型转换**</font>，或者用来处理**字节码指令集中数据类型相关指令**无法与**数据类型**一一对应的问题。

* 宽化类型转换（Widening Numeric Conversions）

  * 转换规则：

    Java虚拟机直接支持以下数值的宽化类型转化（Widening Numeric Conversions，小范围类型向大范围类型的安全转化）。也就是说，并不需要指令执行，包括：

    * 从 int 类型到 long、float或者 double类型。对应的指令为：i2l、i2f、i2d
    * 从 long 类型到 float、double类型。对应的指令为：l2f、l2d
    * 从float类型到 double 类型。对应指令为： f2d

    简化为：int ---> long --> float --> double

    ```java
    //针对于宽化类型转换的基本测试
    public void upCast1() {
        int i = 10;
        long l = i;  // i2l
        float f = i;  // i2f
        double d = i;  // i2d
    
        float f1 = l;  // l2f
        double d1 = l;  // l2d
    
        double d2 = f1;  // f2d
    }
    ```

  * 精度损失问题

    * 宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从 int 转换到 long，或者从 int 转换到 double，都不会丢失任何信息，转换前后的值是精确相等的。
    * 从 int、long 类型数值转换到 float，或者long类型数值转换到 double时，将可能发生精度丢失----可能丢失掉几个最低有效位上的值，转换后的浮点数是根据IEEE754最接近舍入模式所得到的的正确整数值。

    尽管宽化类型转换实际上可能发生精度丢失的，但是这种转换永远不会导致Java虚拟机抛出运行时异常。

    ```java
    //举例：精度损失的问题
    @Test
    public void upCast2() {
        int i = 123123123;
        float f = i;
        System.out.println(f);  // 123123120
    
        long l = 123123123123L;
        l = 123123123123123123L;
        double d = l;
        System.out.println(d);  // 123123123123123120
    }
    ```

  * 补充说明

    <font color=red>**从 byte、char和short类型到int类型的宽化类型转换实际上是不存在的。**</font>对于byte类型转为int，虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交换了两个数据。而将byte转为long时，使用的是i2l，可以看到在内部byte在这里已经等同于int类型处理，类似的还有short类型，这种处理方式有两个特点：

    * 一方面可以减少实际的数据类型，如果为short和byte都准备一套指令，那么指令的数量就会大增，而<font color=red>**虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将short和byte当做int处理也在情理之中。**</font>
    * 另一方面，由于局部变量表中的槽位固定为32位，无论是byte或者short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型。

    ```java
    //针对于byte、short等转换为容量大的类型时，将此类型看做int类型处理。
    public void upCast3(byte b) {
        int i = b;
        long l = b;  // i2l
        double d = b;  // i2d
    }
    
    public void upCast4(short s) {
        int i = s;
        long l = s;  // i2l
        float f = s;  // i2f
    }
    ```

---

* 窄化类型转换（Narrowing Numeric Conversion）

  * 转换规则

    Java虚拟机也直接支持以下**窄化类型转换**：

    * 从 int 类型至byte、short或者char类型。对应的指令有：i2b、i2s、i2c
    * 从long类型到 int类型。对应的指令有：l2i
    * 从 float类型到 int或者long 类型。对应的指令有：f2i、f2l
    * 从 double类型到 int、long或者float类型。对应的指令有：d2i、d2l、d2f

    ```java
    // 窄化类型转换
    // 基本的使用
    public void downCast1() {
        int i = 10;
        byte b = (byte) i;  // i2b
        short s = (short) i;  // i2s
        char c = (char) i;  // i2c
    
        long l = 10L;
        int i1 = (int) l;  // l2i
        byte b1 = (byte) l;  // l2i --> i2b
    }
    
    public void downCast2() {
        float f = 10;
        long l = (long) f;  // f2l
        int i = (int) f;  // f2i
        byte b = (byte) f;  // f2i --> i2b
    
        double d = 10;
        byte b1 = (byte) d;  // d2i --> i2b
    
    }
    
    public void downCast3() {
        short s = 10;
        byte b = (byte) s;  // i2b
    }
    ```

  * 精度损失问题

    窄化类型转换可能会导致转换结果具有不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。

    尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。

  * 补充说明

    当将一个浮点数值窄化为整数类型T（T限于 int 或 long 类型之一）的时候，将遵循以下转换规则：

    * 如果浮点值是NaN，那么转换结果就是int或long类型的0.
    * 如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v，如果v在目标类型T（int或long）的表示范围之内，那转换结果就是v。否则，将根据v的符号，转换为T所能表示的最大或者最小正数

    当将一个 double 类型转换为 float 类型时，将遵循以下转换规则：

    通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。最后结果根据下面3条规则判断：

    * 如果转换结果的绝对值太小而无法使用 float来表示，将返回 float类型的正负零。
    * 如果转换结果的绝对值太大而无法使用 float来表示，将返回 float类型的正负无穷大。
    * 对于 double 类型的 NaN 值将按规定转换为 float 类型的NaN值。

    ```java
    // 测试NaN,无穷大的情况
    @Test
    public void downCast5() {
        double d1 = Double.NaN;  // 0.0 / 0.0
        int i = (int) d1;
        System.out.println(d1);  // NaN
        System.out.println(i);  // 0
    
        double d2 = Double.POSITIVE_INFINITY;
        long l = (long) d2;
        int j = (int) d2;
        System.out.println(l);  // Long.MAX_VALUE
        System.out.println(j);  // Integer.MAX_VALUE
    
        float f = (float) d2;
        System.out.println(f);  // Infinity
    
        float f1 = (float) d1;
        System.out.println(f1);  // NaN
    }
    ```

## 5 对象的创建与访问指令

* Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。

---

* 一、创建指令

  虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。

  * 创建类实例的指令：new

    它接收一个操作数，为指向常量池的索引，表示要创建的类型、执行完成后，将对象的引用压入栈。

    ```java
    public void newInstance() {
        Object obj = new Object();
    
        File file = new File("atguigu.avi");
    }
    ```

    <img src="images/28.png" alt="img" style="zoom:75%;" />

  * 创建数组指令：newarray、anewarray、multianewarray

    * newarray：创建基本类型数组
    * anewarray：创建引用类型数组
    * multianewarray：创建多维数组

  上述创建指令可以用于创建对象或者数组，由于对象和数组在Java中的广泛使用，这些指令的使用频率也非常高。

  ```java
  public void newArray() {
      int[] intArray = new int[10];  // newarray 10 (int)
      Object[] objArray = new Object[10];  // anewarray #2 <java/lang/Object>
      int[][] mintArray = new int[10][10];  // multianewarray #6 <[[I> dim 2
  
      String[][] strArray = new String[10][];  // anewarray #7 <[Ljava/lang/String;>
  }
  ```

  对应的字节码指令如下：

  ```
   0 bipush 10
   2 newarray 10 (int)
   4 astore_1
   5 bipush 10
   7 anewarray #2 <java/lang/Object>
  10 astore_2
  11 bipush 10
  13 bipush 10
  15 multianewarray #6 <[[I> dim 2
  19 astore_3
  20 bipush 10
  22 anewarray #7 <[Ljava/lang/String;>
  25 astore 4
  27 return
  ```

---

* 二、字段访问指令

  对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素。

  * 访问类字段（static字段，或者称为类变量）的指令：getstatic（入栈）、putstatic（出栈）
  * 访问类实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield

  举例：

  以getstatic指令为例，它包含一个操作数，为指向常量池的Fieldref索引，它的作用就是获取Fieldref指定的对象或者值，并将其压入操作数栈。

  ```java
  // 2.字段访问指令
  public void sayHello() {
      System.out.println("hello");
  }
  ```

  对应的字节码指令如下：

  ```
  0 getstatic #8 <java/lang/System.out>
  3 ldc #9 <hello>
  5 invokevirtual #10 <java/io/PrintStream.println>
  8 return
  ```

  <img src="images/29.png" alt="img" style="zoom:80%;" />

  <img src="images/30.png" alt="img" style="zoom:83%;" />

  <img src="images/31.png" alt="img" style="zoom:75%;" />

  另一个例子：

  ```java
  class Order {
      int id;
      static String name;
  }
  
  public class NewTest {
      public void setOrderId() {
          Order order = new Order();
          order.id = 1001;
          System.out.println(order.id);
  
          Order.name = "ORDER";
          System.out.println(Order.name);
      }
  }
  ```

  <img src="images/32.png" alt="img" style="zoom:75%;" />

---

* 三、数组操作指令

  数组操作指令主要有：xastore和xaload。具体为

  * 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload
  * 将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore（这里的store修改的是堆中数组中的某个值，之前讲到的store修改的都是局部变量表中的内容）

  即：

  <img src="images/33.png" alt="img" style="zoom:85%;" />

  * 数组长度的指令：arraylength

    * 该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈

    ```java
    public void arrLength() {
    
        double[] arr = new double[10];
        System.out.println(arr.length);
    }
    ```

    对应的字节码指令如下：

    ```
     0 bipush 10
     2 newarray 7 (double)
     4 astore_1
     5 getstatic #8 <java/lang/System.out>
     8 aload_1
     9 arraylength
    10 invokevirtual #14 <java/io/PrintStream.println>
    13 return
    ```

  **说明：**

  * 指令xaload表示将数组元素压栈，比如saload、caload分别表示压入short数组和char数组。指令xaload在执行时，要求操作数中栈顶元素为数组索引i，栈顶顺位第二个元素为数组引用a，该指令会弹出栈顶这两个元素，并将a[i] 重新压入栈。

  * xastore则专门针对数组操作，以iastore为例，它用于给一个 int 数组的给定索引赋值。在iastore执行前，操作数栈顶需要以此准备 3 个元素：值、索引、数组索引，iastore会弹出这 3 个值，并将值赋给数组中指定索引的位置。

    ```java
    // 3.数组操作指令
    public void setArray() {
        int[] intArray = new int[10];
        intArray[3] = 20;
        System.out.println(intArray[1]);
    }
    ```

    <img src="images/34.png" alt="img" style="zoom:85%;" />

---

* 四、类型检查指令

  检查类实例或数组或数组类型的指令：instanceof、checkcast。

  * 指令checkcast用于检查类型强制转换是否可以进行。如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出ClassCastException异常。
  * 指令instancdof用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈。

  ```java
  // 4.类型检查指令
  public String checkCast(Object obj) {
      if (obj instanceof String) {
          return (String) obj;
      } else {
          return null;
      }
  }
  ```

  对应的字节码指令如下：

  ```
   0 aload_1
   1 instanceof #17 <java/lang/String>
   4 ifeq 12 (+8)
   7 aload_1
   8 checkcast #17 <java/lang/String>
  11 areturn
  12 aconst_null
  13 areturn
  ```




## 6 方法调用与返回指令

* 方法调用指令：invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic

  以下5条指令用于方法调用：

  * invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言<font color=red>**最常见的方法分派方式**</font>。

    ```java
    // 方法调用指令:invokevirtual:动态分派
    public void invoke4() {
        System.out.println("hello");
    
        Thread t1 = null;
        t1.run();
    }
    ```

    ```
     0 getstatic #12 <java/lang/System.out>
     3 ldc #13 <hello>
     5 invokevirtual #14 <java/io/PrintStream.println>
     8 aconst_null
     9 astore_1
    10 aload_1
    11 invokevirtual #15 <java/lang/Thread.run>
    14 return
    ```

  * invokeinterface 指令用于<font color=red>**调用接口方法**</font>，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。

    ```java
    // 方法调用指令: invokeinterface
    public void invoke3() {
        Thread t1 = new Thread();
        ((Runnable) t1).run();
    
        Comparable<Integer> com = null;
        com.compareTo(123);
    }
    ```

    ```
     0 new #4 <java/lang/Thread>
     3 dup
     4 invokespecial #5 <java/lang/Thread.<init>>
     7 astore_1
     8 aload_1
     9 invokeinterface #9 <java/lang/Runnable.run> count 1
    14 aconst_null
    15 astore_2
    16 aload_2
    17 bipush 123
    19 invokestatic #10 <java/lang/Integer.valueOf>
    22 invokeinterface #11 <java/lang/Comparable.compareTo> count 2
    27 pop
    28 return
    ```

  * invokespecial 指令用于调用一些小特殊处理的实例方法，包括<font color=red>**实例初始化方法（构造器）、私有方法和父类方法**</font>（不能够重写）。这些方法都是静态类型绑定的，不会再调用时进行动态派发。

    ```java
    // 方法调用指令: invokespecial:静态分派
    public void invoke1() {
        // 情况1：类实例构造器方法：<init>()
        Date date = new Date();
        Thread t1 = new Thread();
        // 情况2：父类的方法
        super.toString();
        // 情况3：私有方法
        methodPrivate();
    }
    
    private void methodPrivate() {
    
    }
    ```

    ```
     0 new #2 <java/util/Date>
     3 dup
     4 invokespecial #3 <java/util/Date.<init>>
     7 astore_1
     8 new #4 <java/lang/Thread>
    11 dup
    12 invokespecial #5 <java/lang/Thread.<init>>
    15 astore_2
    16 aload_0
    17 invokespecial #6 <java/lang/Object.toString>
    20 pop
    21 aload_0
    22 invokespecial #7 <com/atguigu/java/MethodInvokeReturnTest.methodPrivate>
    25 return
    ```

  * invokestatic 指令用于调用<font color=red>**类中的类方法（static方法）**</font>。这是静态绑定的。

    ```java
    // 方法调用指令: invokestatic:静态分派
    public void invoke2() {
        methodStatic();
    }
    
    public static void methodStatic() {
    
    }
    ```

    ```
    0 invokestatic #8 <com/atguigu/java/MethodInvokeReturnTest.methodStatic>
    3 return
    ```

  * invokedynamic：调用动态绑定方法，这个是JDK 1.7后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分配逻辑都固话在java虚拟机内部，而invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。

  一个注意点：

  ```java
  public class InterfaceMethodTest {
      public static void main(String[] args) {
          AA aa = new BB();
  
          aa.method2();
  
          AA.method1();
      }
  }
  
  
  interface AA {
      public static void method1() {
  
      }
  
      public default void method2() {
  
      }
  }
  
  class BB implements AA {
  
  }
  ```

  ```
   0 new #2 <com/atguigu/java/BB>
   3 dup
   4 invokespecial #3 <com/atguigu/java/BB.<init>>
   7 astore_1
   8 aload_1
   9 invokeinterface #4 <com/atguigu/java/AA.method2> count 1
  14 invokestatic #5 <com/atguigu/java/AA.method1>
  17 return
  ```

---

* 方法返回指令

  在方法调用结束之前，需要进行返回。方法返回指令是<font color=red>**根据返回值类型区分**</font>的。

  * 包括ireturn（当返回值是boolean、byte、char、short 和 int 类型时使用）、lreturn、dreturn和 areturn
  * 另外还有一条return指令供声明为 void的方法，实例初始化方法以及类和接口的初始化方法使用。

  | 返回类型                          | 返回指令 |
  | --------------------------------- | -------- |
  | void                              | return   |
  | int（boolean、byte、char、short） | ireturn  |
  | long                              | lreturn  |
  | float                             | freturn  |
  | double                            | dreturn  |
  | reference                         | areturn  |

  举例：

  通过ireturn指令，将当前函数操作数栈的栈顶元素弹出，并将这个元素压入调用者函数的操作栈中（因为调用者非常关心函数的返回值），所有在当前函数操作栈中的其他元素都会被丢弃。

  如果当前返回的是synchronized方法，那么还会执行一个隐含的monitorexit指令，退出临界区。

  最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。

  ```java
  // 方法的返回指令
  public int returnInt() {
      int i = 500;
      return i;  // ireturn
  }
  
  public double returnDouble() {
      return 0.0;  // dreturn
  }
  
  public String returnString() {
      return "hello,world";  // areturn
  }
  
  public int[] returnArr() {
      return null;  // areturn
  }
  
  public float returnFloat() {
      int i = 10;
      return i;  // freturn
  }
  
  public byte returnByte() {
      return 0;  // ireturn
  }
  
  public void methodReturn() {
      int i = returnByte();
  }
  ```

  

## 7 操作数栈管理指令

* 如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。

* 这类指令包括如下内容：

  * 将一个或两个元素从栈顶弹出，并且直接废弃：pop，pop2；
  * 赋值栈顶的一个或者两个数值并将复制值或双份的复制值重新压入栈顶：dup，dup2，dup_x1，dup2_x1，dup_x2，dup2_x2；
  * 将栈最顶端的两个slot数值位置交换：swap。Java虚拟机没有提供交换两个64位数据类型（long、double）数值的指令。
  * 指令nop，是一个非常特殊的指令，它的字节码为0x00。和汇编语言中的nop一样，它表示什么都不做，这条指令一般用于调试、占位等。

  这些指令属于通用型，对栈的压入或者弹出无需指明数据类型。

  **说明：**

  * 不带_x的指令是复制栈顶数据并压入栈顶。包括两个指令，dup和dup2。dup的系数代表要复制的slot个数。
    * dup开头的指令用于复制1个slot的数据。例如 1 个int或 1 个reference类型数据
    * dup2开头的指令用于复制 2 个slot的数据。例如一个long，或者 2 个int，或 1个int + 1个float类型的数据
  * 带\_x的指令是复制栈顶数据并插入栈顶以下的某个位置。供有 4 个指令，dup_x1，dup2_x1，dup_x2，dup2_x2。对于带\_x的复制插入指令，只要将指令的dup和x的系数相加，结果即为需要插入的位置。因此：
    * dup_x1插入位置：1+1=2，即栈顶 2 个slot下面
    * dup_x2插入位置：1+2=3，即栈顶 3 个slot下面
    * dup2_x1插入位置：2+1=3，即栈顶 3 个slot下面
    * dup2_x2插入位置：2+2=4，即栈顶 4 个slot下面
  * pop：将栈顶的 1 个slot数值出栈。例如 1 个short类型数值
  * pop2：将栈顶的 2 个slot数值出栈。例如 1 个double类型，或者 2 个int类型数据。

  ```java
  public void print() {
      Object obj = new Object();
      // String info = obj.toString();
      obj.toString();
  }
  ```

  ```
   0 new #3 <java/lang/Object>
   3 dup
   4 invokespecial #1 <java/lang/Object.<init>>
   7 astore_1
   8 aload_1
   9 invokevirtual #4 <java/lang/Object.toString>
  12 pop
  13 return
  ```

  ```java
  // 类似的
  public void foo() {
      bar();
  }
  
  public long bar() {
      return 0;
  }
  ```

  ```
  0 aload_0
  1 invokevirtual #5 <com/atguigu/java/StackOperateTest.bar>
  4 pop2
  5 return
  ```

  ```java
  public class StackOperateTest {
  
      public long nextIndex() {
          return index++;
      }
  
      private long index = 0;
  }
  ```

  ```
   0 aload_0
   1 dup
   2 getfield #2 <com/atguigu/java/StackOperateTest.index>
   5 dup2_x1
   6 lconst_1
   7 ladd
   8 putfield #2 <com/atguigu/java/StackOperateTest.index>
  11 lreturn
  ```

  

## 8 控制转移指令

* 条件跳转指令

  程序流程控制离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体可以分为：

  （1）比较指令、（2）条件跳转指令、（3）比较条件跳转指令、（4）多条件分支跳转指令、（5）无条件跳转指令等。

---

* **比较指令的说明：**

  * 比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈。
  * 比较指令有：dcmpg、dcmpl、fcmpg、fcmpl、lcmp
    * 与前面讲解的指令类似，首字符d表示double类型，f表示float，l表示long。
  * 对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg、fcmpl两个指令，他们的区别在于数字比较时，若遇到NaN值，处理结果不同。
  * 指令dcmpg、dcmpl也是类似的，根据其命名可以推断其含义，在此不再赘述。
  * 指令lcmp针对long型整数，由于long型整数没有NaN值，故无需准备两套指令。

  举例：

  * 指令fcmpg、fcmpl都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为 v2，栈顶顺位第2位元素为 v1，若 v1 == v2，则压入0；若v1 > v2，则压入1；若v1 < v2，则压入-1。
  * 两个指令的区别之处在于，当遇到NaN值，fcmpg会压入 1， 而fcmpl 会压入 -1。

  数值类型的数据，才可以比较大小！（byte\short\char\int；long\float\double）

  boolean、引用数据类型不能比较大小。

---

* **条件跳转指令**

  条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。

  条件跳转指令有：ifeq，iflt，ifle，ifne，ifgt，ifge，ifnull，ifnonnull。这些指令都接受两个字节的操作数，用于计算跳转的位置（16位有符号整数作为当前位置的offset）。

  它们的统一含义为：<font color=red>**弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳到给定位置。**</font>

  **具体说明：**

  |   指令    |               含义               |
  | :-------: | :------------------------------: |
  |   ifeq    |   当栈顶int类型数值等于0时跳转   |
  |   ifne    |  当栈顶int类型数值不等于0时跳转  |
  |   iflt    |   当栈顶int类型数值小于0时跳转   |
  |   ifle    | 当栈顶int类型数值小于等于0时跳转 |
  |   ifgt    |   当栈顶int类型数值大于0时跳转   |
  |   ifge    | 当栈顶int类型数值大于等于0时跳转 |
  |  ifnull   |           为null时跳转           |
  | ifnonnull |          不为null时跳转          |

  **注意：**

  1. 与前面运算规则一致：
     * 对于boolean、byte、char、short类型的条件分支比较指令，都是使用int类型的比较指令完成的
     * 对于long、float、double类型的条件分支指令比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整数型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转。
  2. 由于各类型的比较操作最终都会转为 int 类型的比较操作，所以Java虚拟机提供的 int 类型的条件分支指令是最为丰富和强大的。

  ```java
  // 1.条件跳转指令
  public void compare1() {
      int a = 0;
      if (a != 0) {
          a = 10;
      } else {
          a = 20;
      }
  }
  ```

  ```
   0 iconst_0
   1 istore_1
   2 iload_1
   3 ifeq 12 (+9)
   6 bipush 10
   8 istore_1
   9 goto 15 (+6)
  12 bipush 20
  14 istore_1
  15 return
  ```

  

  ```java
  public boolean compareNull(String str) {
      if (str == null) {
          return true;
      } else {
          return false;
      }
  }
  ```

  ```
  0 aload_1
  1 ifnonnull 6 (+5)
  4 iconst_1
  5 ireturn
  6 iconst_0
  7 ireturn
  ```

  ```java
  // 结合比较指令
  public void compare2() {
      float f1 = 9;
      float f2 = 10;
      System.out.println(f1 < f2);//true
  }
  ```

  <img src="images/35.png" alt="img" style="zoom:80%;" />

  

  ```java
  public void compare3() {
      int i1 = 10;
      long l1 = 20;
      System.out.println(i1 > l1);
  }
  ```

  ```
   0 bipush 10
   2 istore_1
   3 ldc2_w #6 <20>
   6 lstore_2
   7 getstatic #4 <java/lang/System.out>
  10 iload_1
  11 i2l
  12 lload_2
  13 lcmp
  14 ifle 21 (+7)
  17 iconst_1
  18 goto 22 (+4)
  21 iconst_0
  22 invokevirtual #5 <java/io/PrintStream.println>
  25 return
  ```

  ```java
  public int compare4(double d) {
      if (d > 50.0) {
          return 1;
      } else {
          return -1;
      }
  }
  ```

  ```
   0 dload_1
   1 ldc2_w #8 <50.0>
   4 dcmpl
   5 ifle 10 (+5)
   8 iconst_1
   9 ireturn
  10 iconst_m1
  11 ireturn
  ```

---

* **比较条件跳转指令**

  比较条件跳转指令类似于比较指令和条件指令的的结合体，它将比较和跳转两个步骤合二为一。

  这类指令有：if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq 和 if_acmpne。其中指令助记符加上"if_"后，以字符"i"开头的指令针对 int 型整数操作（也包括short和byte类型），以字符"a"开头的指令表示对象引用的比较。

  **具体说明：**

  |   指令    |                             含义                             |
  | :-------: | :----------------------------------------------------------: |
  | if_icmpeq | 比较栈顶两 int 类型数值大小，当前者等于后者(栈顶对应元素)时跳转 |
  | if_icmpne |     比较栈顶两 int 类型数值大小，当前者不等于后者时跳转      |
  | if_icmplt |      比较栈顶两 int 类型数值大小，当前者小于后者时跳转       |
  | if_icmple |    比较栈顶两 int 类型数值大小，当前者小于等于后者时跳转     |
  | if_icmpgt |      比较栈顶两 int 类型数值大小，当前者大于后者时跳转       |
  | if_icmpge |    比较栈顶两 int 类型数值大小，当前者大于等于后者时跳转     |
  | if_acmpeq |           比较栈顶两引用类型数值，当结果相等时跳转           |
  | if_acmpne |          比较栈顶两引用类型数值，当结果不相等时跳转          |

  这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置：同时在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的两个元素被清空，且没有任何数据入栈。<font color=red>**如果预设条件成立，则执行跳转，否则，继续执行下一条语句。**</font>

  ```java
  // 2.比较条件跳转指令
  public void ifCompare1() {
      int i = 10;
      int j = 20;
      System.out.println(i > j);
  }
  
  ```

  ```
   0 bipush 10
   2 istore_1
   3 bipush 20
   5 istore_2
   6 getstatic #4 <java/lang/System.out>
   9 iload_1
  10 iload_2
  11 if_icmple 18 (+7)
  14 iconst_1
  15 goto 19 (+4)
  18 iconst_0
  19 invokevirtual #5 <java/io/PrintStream.println>
  22 return
  ```

  ```java
  public void ifCompare2() {
      short s1 = 9;
      byte b1 = 10;
      System.out.println(s1 > b1);
  }
  ```

  ```
   0 bipush 9
   2 istore_1
   3 bipush 10
   5 istore_2
   6 getstatic #4 <java/lang/System.out>
   9 iload_1
  10 iload_2
  11 if_icmple 18 (+7)
  14 iconst_1
  15 goto 19 (+4)
  18 iconst_0
  19 invokevirtual #5 <java/io/PrintStream.println>
  22 return
  ```

  ```java
  public void ifCompare3() {
      Object obj1 = new Object();
      Object obj2 = new Object();
      System.out.println(obj1 == obj2);  // false
      System.out.println(obj1 != obj2);  // true
  }
  ```

  ```
   0 new #10 <java/lang/Object>
   3 dup
   4 invokespecial #1 <java/lang/Object.<init>>
   7 astore_1
   8 new #10 <java/lang/Object>
  11 dup
  12 invokespecial #1 <java/lang/Object.<init>>
  15 astore_2
  16 getstatic #4 <java/lang/System.out>
  19 aload_1
  20 aload_2
  21 if_acmpne 28 (+7)
  24 iconst_1
  25 goto 29 (+4)
  28 iconst_0
  29 invokevirtual #5 <java/io/PrintStream.println>
  32 getstatic #4 <java/lang/System.out>
  35 aload_1
  36 aload_2
  37 if_acmpeq 44 (+7)
  40 iconst_1
  41 goto 45 (+4)
  44 iconst_0
  45 invokevirtual #5 <java/io/PrintStream.println>
  48 return
  ```

---

* **多条件分支跳转指令**

  多条件分支跳转指令是专为 switch-case 语句设计的，主要有 tableswitch 和 lookupswitch。

  |   指令名称   |                描述                |
  | :----------: | :--------------------------------: |
  | tableswitch  |   用于switch条件跳转，case值连续   |
  | lookupswitch | 用于 switch 条件跳转，case值不连续 |

  从助记符上看，两者都是 switch 语句的实现，他们的区别：

  * tableswitch要求<font color=red>**多个条件分支是连续的**</font>，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数index，可以立即定位到跳转偏移量位置，<font color=red>**因此效率比较高**</font>。
  * 指令lookupswitch内部<font color=red>**存放着各个离散的case-offset对**</font>，每次执行都要搜索全部的case-offset对，找到匹配的case值，并根据对应的offset计算跳转地址，<font color=red>**因此效率比较低**</font>。

  指令 tableswitch 的示意图如下图所示。由于 tableswitch 的 case值是连续的，因此只需要记录最低值和最高值，以及每一项对应的offset偏移量，根据给定的index值通过简单的计算即可定位到offset。

  <img src="images/36.png" alt="img" style="zoom:90%;" />
  
  指令lookupswitch处理的是离散的case值，但是出于效率考虑，<font color=red>**将case-offset对按照case值大小排序**</font>，给定index时，需要查找与index相等的case，获得其offset，如果找不到则跳转到default。指令lookupswitch如下图所示。
  
  <img src="images/37.png" alt="img" style="zoom:90%;" />
  
  * 
  
  ```java
  // 3.多条件分支跳转
  public void swtich1(int select) {
      int num;
      switch (select) {
          case 1:
              num = 10;
              break;
          case 2:
              num = 20;
              //break;
          case 3:
              num = 30;
              break;
          default:
              num = 40;
      }
  }
  ```
  
  ```
   0 iload_1
   1 tableswitch 1 to 3	1:  28 (+27)
  						2:  34 (+33)
                          3:  37 (+36)
                          default:  43 (+42)
  28 bipush 10
  30 istore_2
  31 goto 46 (+15)
  34 bipush 20
  36 istore_2
  37 bipush 30
  39 istore_2
  40 goto 46 (+6)
  43 bipush 40
  45 istore_2
  46 return
  ```
  
  
  
  ```java
  public void swtich2(int select) {
      int num;
      switch (select) {
          case 100:
              num = 10;
              break;
          case 500:
              num = 20;
              break;
          case 200:
              num = 30;
              break;
          default:
              num = 40;
      }
  }
  ```
  
  ```
   0 iload_1
   1 lookupswitch 3
  				100:  36 (+35)
  				200:  48 (+47)
  				500:  42 (+41)
  				default:  54 (+53)
  36 bipush 10
  38 istore_2
  39 goto 57 (+18)
  42 bipush 20
  44 istore_2
  45 goto 57 (+12)
  48 bipush 30
  50 istore_2
  51 goto 57 (+6)
  54 bipush 40
  56 istore_2
  57 return
  ```
  
  ```java
  // jdk7新特性：引入String类型
  public void swtich3(String season) {
      switch (season) {
          case "SPRING":
              break;
          case "SUMMER":
              break;
          case "AUTUMN":
              break;
          case "WINTER":
              break;
      }
  }
  ```
  
  ```
    0 aload_1
    1 astore_2
    2 iconst_m1
    3 istore_3
    4 aload_2
    5 invokevirtual #11 <java/lang/String.hashCode>
    8 lookupswitch 4
                  -1842350579:  52 (+44)
                  -1837878353:  66 (+58)
                  -1734407483:  94 (+86)
                  1941980694:  80 (+72)
                  default:  105 (+97)
   52 aload_2
   53 ldc #12 <SPRING>
   55 invokevirtual #13 <java/lang/String.equals>
   58 ifeq 105 (+47)
   61 iconst_0
   62 istore_3
   63 goto 105 (+42)
   66 aload_2
   67 ldc #14 <SUMMER>
   69 invokevirtual #13 <java/lang/String.equals>
   72 ifeq 105 (+33)
   75 iconst_1
   76 istore_3
   77 goto 105 (+28)
   80 aload_2
   81 ldc #15 <AUTUMN>
   83 invokevirtual #13 <java/lang/String.equals>
   86 ifeq 105 (+19)
   89 iconst_2
   90 istore_3
   91 goto 105 (+14)
   94 aload_2
   95 ldc #16 <WINTER>
   97 invokevirtual #13 <java/lang/String.equals>
  100 ifeq 105 (+5)
  103 iconst_3
  104 istore_3
  105 iload_3
  106 tableswitch 0 to 3	0:  136 (+30)
  						1:  139 (+33)
  						2:  142 (+36)
  						3:  145 (+39)
  						default:  145 (+39)
  136 goto 145 (+9)
  139 goto 145 (+6)
  142 goto 145 (+3)
  145 return
  ```
  

---

* **无条件跳转指令**

  目前主要的无条件跳转指令为goto。指令goto接收两个字节的操作数，共同组成功过一个带符号的整数，<font color=red>**用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的为位置处**</font>。

  如果指令偏移量太大，超过双字节的带符号整数范围，则可以使用goto_w，它和goto有相同的作用，但是它接收4个字节的操作数，可以表示更大的范围。

  指令jsr、jsr_w、ret虽然也是无条件跳转，但主要用于 try-finally语句，且已经被虚拟机逐渐废弃，故不再这里介绍。

  | 指令名称 |                             描述                             |
  | :------: | :----------------------------------------------------------: |
  |   goto   |                          无条件跳转                          |
  |  got_w   |                     无条件跳转（宽索引）                     |
  |   jsr    |     跳转至指定16位offset位置，并将jsr下一条指令压入栈顶      |
  |  jsr_w   |    跳转至指定32位offset位置，并将jsr_w下一条指令压入栈顶     |
  |   ret    | 返回由指定的局部变量所给出的指令位置（一般与jsr、jsr_w联合使用） |

  ```java
  // 4.无条件跳转指令
  public void whileInt() {
      int i = 0;
      while (i < 100) {
          String s = "atguigu.com";
          i++;
      }
  }
  ```

  ```
   0 iconst_0
   1 istore_1
   2 iload_1
   3 bipush 100
   5 if_icmpge 17 (+12)
   8 ldc #17 <atguigu.com>
  10 astore_2
  11 iinc 1 by 1
  14 goto 2 (-12)
  17 return
  ```

  ```java
  public void whileDouble() {
      double d = 0.0;
      while (d < 100.1) {
          String s = "atguigu.com";
          d++;
      }
  }
  ```

  ```
   0 dconst_0
   1 dstore_1
   2 dload_1
   3 ldc2_w #18 <100.1>
   6 dcmpg
   7 ifge 20 (+13)
  10 ldc #17 <atguigu.com>
  12 astore_3
  13 dload_1
  14 dconst_1
  15 dadd
  16 dstore_1
  17 goto 2 (-15)
  20 return
  ```

  ```java
  public void printFor() {
      short i;
      for (i = 0; i < 100; i++) {
          String s = "atguigu.com";
      }
  }
  ```

  ```
   0 iconst_0
   1 istore_1
   2 iload_1
   3 bipush 100
   5 if_icmpge 19 (+14)
   8 ldc #17 <atguigu.com>
  10 astore_2
  11 iload_1
  12 iconst_1
  13 iadd
  14 i2s
  15 istore_1
  16 goto 2 (-14)
  19 return
  ```

  

## 9 异常处理指令

* 抛出异常指令

  athrow指令：

  * 在 Java 程序中显示抛出异常的操作（throw语句）都是由athrow指令来实现。
  * 除了使用throw语句显示抛出异常情况之外，<font color=red>**JVM规范还规定了许多运行时异常，这些异常会在其他Java虚拟机指令检测到异常状况时自动抛出。**</font>例如，在之前介绍的整数运算中，当除数为0时，虚拟机会在 idiv 或 ldiv指令中抛出 ArithmeticException异常。

  注意：

  * 正常情况下，操作数栈的压入弹出指令都是一条条指令完成的。唯一的例外情况是在<font color=red>**再抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作栈上。**</font>

  ##########

  异常及异常的处理：

  * 过程1：异常对象的生成过程 ---> throw（手动 / 自动）   --->  指令：athrow
  * 过程2：异常的处理：抓抛模型。 try-catch-finally  ---> 使用异常表

  ```java
  public void throwZero(int i) {
      if (i == 0) {
          throw new RuntimeException("参数值为0");
      }
  }
  ```

  ```
   0 iload_1
   1 ifne 14 (+13)
   4 new #2 <java/lang/RuntimeException>
   7 dup
   8 ldc #3 <参数值为0>
  10 invokespecial #4 <java/lang/RuntimeException.<init>>
  13 athrow
  14 return
  ```

  ```java
  public void throwOne(int i) throws RuntimeException, IOException {
      if (i == 1) {
          throw new RuntimeException("参数值为1");
      }
  }
  ```

  ```
   0 iload_1
   1 iconst_1
   2 if_icmpne 15 (+13)
   5 new #2 <java/lang/RuntimeException>
   8 dup
   9 ldc #5 <参数值为1>
  11 invokespecial #4 <java/lang/RuntimeException.<init>>
  14 athrow
  15 return
  ```

  ![img](images/38.png)

  对于系统已经定义好的异常，JVM会自动抛出，如下的例子，我们在字节码中看不到 athrow

  ```java
  public void throwArithmetic() {
      int i = 10;
      int j = i / 0;
      System.out.println(j);
  }
  ```

  ```
   0 bipush 10
   2 istore_1
   3 iload_1
   4 iconst_0
   5 idiv
   6 istore_2
   7 getstatic #6 <java/lang/System.out>
  10 iload_2
  11 invokevirtual #7 <java/io/PrintStream.println>
  14 return
  ```

---

* 异常处理和异常表

  **异常处理：**

  * 在Java虚拟机中，<font color=red>**异常处理**</font>（catch语句）不是由字节码指令来实现的（早期使用jsr、ret指令），而是<font color=red>**采用异常表来完成的**</font>。

  **异常表：**

  * 如果在一个方法定义了一个try-catch 或者 try-finally 的异常处理，就会创建一个异常表。它包含了每个异常处理或者 finally 块的信息。异常表保存了每个异常处理信息。比如：
    * 起始位置
    * 结束位置
    * 程序计数器记录的代码处理的偏移地址
    * 被捕获的异常表在常量池中的索引

  <font color=red>**当一个异常被抛出时，JVM会在当前方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出栈帧**</font>，并且异常会重新抛给上层调用的方法（在调用方法栈帧）。如果在所有栈帧弹出前仍没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将导致JVM字节终止，比如这个线程是main线程。

  <font color=red>**不管什么时候抛出异常。如果异常处理最终匹配了所有异常类型，代码就会继续执行**</font>。这种情况下，如果方法结束后没有抛出异常，仍然执行finally块，在return之前，它直接跳到finally块来完成目标。

  <img src="images/39.png" alt="img" style="zoom:80%;" />

  * 面试题：

    ```java
    // 思考：如下方法返回结果为多少？   hello
    public static String func() {
        String str = "hello";
        try {
            return str;
        } finally {
            str = "atguigu";
        }
    }
    ```

    ```
     0 ldc #17 <hello>
     2 astore_0
     3 aload_0
     4 astore_1
     5 ldc #18 <atguigu>
     7 astore_0
     8 aload_1
     9 areturn
    10 astore_2
    11 ldc #18 <atguigu>
    13 astore_0
    14 aload_2
    15 athrow
    ```

    

## 10 同步控制指令

* **组成**

  Java虚拟机支持两种同步结构：<font color=red>**方法级的同步**</font> 和 <font color=red>**方法内部一段指令序列的同步**</font>，这两种同步都是使用monitor来支持的。

* **方法级的同步**

  方法级的同步是隐式的，即无需通过字节码指令来控制，它实现在方法调用和方法返回操作之中。虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志的值一个方法是否声明为同步方法；

  当调用方法时，调用指令将会检查方法ACC_SYNCHRONIZED访问标志是否设置。

  * 如果设置了，执行线程将先持有同步锁，然后执行方法。<font color=red>**最后**</font>在方法完成（无论是正常完成还是非正常完成）时<font color=red>**释放同步锁**</font>。
  * 在方法执行期间，执行线程持有同步锁，其他线程持有了同步锁，其他任何线程都无法再获得同一个锁。
  * 如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛出的同步方法之外时自动释放。

  举例：

  ```java
  private int i = 0;
  
  public synchronized void add() {
      i++;
  }
  ```

  ```
   0 aload_0
   1 dup
   2 getfield #2 <com/atguigu/java1/SynchronizedTest.i>
   5 iconst_1
   6 iadd
   7 putfield #2 <com/atguigu/java1/SynchronizedTest.i>
  10 return
  ```

  **说明：**

  这段代码和普通的无同步操作的代码没有什么不同，没有使用monitorenter和monitorexit进行同步区控制。这是因为，对于同步方法而言，<font color=red>**当虚拟机通过方法的访问标识符判断一个同步方法时，会自动在方法调用前进行加锁**</font>，当同步方法执行完毕后，不管方法时正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，monitorenter和monitorexit 指令是隐式存在的，并未直接出现在字节码中。

---

* **方法内指定序列的同步**

  * 同步一段指令序列：通常由Java中的synchronized语句块来表示的。jvm的指令集有monitorenter和monitorexit 两条指令来支持 synchronized关键字的语义。

  * 当一个线程进入同步代码块时，它使用monitorenter指令请求进入。如果当前对象的监视器为0，则它会被允许进入，若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，知道对象的监视器计数器为0，才会被允许进入同步块。

  * 当线程退出同步代码块时，需要使用monitorexit声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。

  * 指令monitorenter和monitorexit 在执行时，都需要操作数栈顶压入对象，之后monitorenter和monitorexit 的锁定和释放都是针对这个对象的监视器进行的。

  * 下图展示了监视器如何保护临界区代码不同时被多个线程访问，只有当线程4离开临界区后，线程1、2、3才有可能进入。

  <img src="images/40.png" alt="img" style="zoom:90%;" />

  举例：

  ```java
  public class SynchronizedTest {
  
      private int i = 0;
  
      public void subtract() {
          synchronized (obj) {
              i--;
          }
      }
  }
  ```

  <img src="images/41.png" alt="img" style="zoom:70%;" />

  * 编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。
  * 为了保证在方法异常完成时monitorenter和monitorexit 指令依然可以正确配对执行，<font color=red>**编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常**</font>，它的目的就是用来执行monitorexit指令。

