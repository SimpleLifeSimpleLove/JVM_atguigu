# 第21章 再谈类的加载器

## 1 概述

* 类加载器是JVM执行类加载机制的前提。

* **ClassLoader的作用：**

  ClassLoader是Java的核心组件，所有Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。

  <img src="images/48.png" alt="img" style="zoom:80%;" />

  类加载器最早出现在Java1.0版本中，那个时候只是为了单纯满足Java Applet应用而研发出来。但如今类加载器却在OSGi、字节码加密解密领域大放异彩。这主要归功于Java虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在JVM内部，这样做的好处就是能够更加灵活和动态执行类加载操作。

---

* 大厂面试题
  * ==蚂蚁金服​==
    * 深入分析ClassLoader，双亲委派机制
    * 类加载器的双亲委派模型是什么？
    * 一面：双亲委派机制及使用原因
  * ==百度==
    * 都有哪些类加载器，这些类加载器都加载哪些文件？
    * 手写一个类加载器Demo
    * Class的forName("java.lang.String") 和 Class的getClassLoader()的loadClass("java.lang.String")有什么区别？
  * ==腾讯==
    * 什么是双亲委派机制？
    * 类加载器有哪些？
  * ==小米==
    * 双亲委派机制介绍一下
  * ==滴滴==
    * 简单说一下你了解的类加载器
    * 一面：讲一下双亲委派模型，以及其优点
  * ==字节跳动==
    * 什么是类加载器，类加载器有哪些？
  * ==京东==
    * 类加载器的双亲委派模型是什么？
    * 双亲委派机制可以打破吗？为什么？

---

* **类的加载分类：显示加载 vs 隐式加载**

  class文件的显示加载与隐式加载的方式是 指JVM加载class文件到内存的方式。

  * 显示加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。
  * 隐式加载则不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另一个类的对象，此时额外引用的类将通过JVM自动被加载到内存中。

  在日常开发以上两种方式一般会混合使用。

  ```java
  package com.atguigu.java;
  
  public class User {
      private int id;
  
      @Override
      public String toString() {
          return "User{" +
                  "id=" + id +
                  '}';
      }
  }
  ```

  ```java
  public class UserTest {
      public static void main(String[] args) {
          User user = new User();  // 隐式加载
  
          try {
              Class clazz = Class.forName("com.atguigu.java.User");  // 显式加载
              ClassLoader.getSystemClassLoader().loadClass("com.atguigu.java.User");  // 显式加载
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          }
      }
  }
  ```

---

* 类加载器的必要性

  一般情况下，Java开发人员并不需要在程序中显示地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：

  * 避免在开发中遇到java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速的根据错误日志定位问题和解决问题。
  * 需要支持类的动态加载或需要对编译后的字节码文件进行加密操作时，就需要与类加载器打交道了。
  * 开发人员可以在程序中编写自定义类加载器重新定义类的加载规则，一遍实现一些自定义的处理逻辑。

---

* **何为类的唯一性？**

  对于任意一个类，<font color=red>**都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。**</font>每一个类加载器，都拥有一个独立的类名称空间：<font color=red>**比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。**</font>否则，即使这两个类源自于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那么这两个类就不定不相同。

* 命名空间

  * 每个类加载器都有自己的命名空间，命名空间由该加载器及及所有父加载器所加载的类组成
  * 在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类
  * 在不同的命名空间中，有可能出现类的完整名字（包括类的包名）相同的两个类

  在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。

  ```java
  public class UserClassLoader extends ClassLoader {
      private String rootDir;
  
      public UserClassLoader(String rootDir) {
          this.rootDir = rootDir;
      }
  
      /**
       * 编写findClass方法的逻辑
       */
      @Override
      protected Class<?> findClass(String name) throws ClassNotFoundException {
          // 获取类的class文件字节数组
          byte[] classData = getClassData(name);
          if (classData == null) {
              throw new ClassNotFoundException();
          } else {
              // 直接生成class对象
              return defineClass(name, classData, 0, classData.length);
          }
      }
  
      /**
       * 编写获取class文件并转换为字节码流的逻辑 * @param className * @return
       */
      private byte[] getClassData(String className) {
          // 读取类文件的字节
          String path = classNameToPath(className);
          try {
              InputStream ins = new FileInputStream(path);
              ByteArrayOutputStream baos = new ByteArrayOutputStream();
              byte[] buffer = new byte[1024];
              int len = 0;
              // 读取类文件的字节码
              while ((len = ins.read(buffer)) != -1) {
                  baos.write(buffer, 0, len);
              }
              return baos.toByteArray();
          } catch (IOException e) {
              e.printStackTrace();
          }
          return null;
      }
  
      /**
       * 类文件的完全路径
       */
      private String classNameToPath(String className) {
          return rootDir + "\\" + className.replace('.', '\\') + ".class";
      }
  
      public static void main(String[] args) {
          String rootDir = "D:\\code\\workspace_idea5\\JVMDemo1\\chapter04\\src\\";
  
          try {
              // 创建自定义的类的加载器1
              UserClassLoader loader1 = new UserClassLoader(rootDir);
              Class clazz1 = loader1.findClass("com.atguigu.java.User");
  
              // 创建自定义的类的加载器2
              UserClassLoader loader2 = new UserClassLoader(rootDir);
              Class clazz2 = loader2.findClass("com.atguigu.java.User");
  
              System.out.println(clazz1 == clazz2);  // clazz1 与 clazz2对应了不同的类模板结构。
              System.out.println(clazz1.getClassLoader());
              System.out.println(clazz2.getClassLoader());
  
              //######################
              Class clazz3 = ClassLoader.getSystemClassLoader().loadClass("com.atguigu.java.User");
              System.out.println(clazz3.getClassLoader());
  
              System.out.println(clazz1.getClassLoader().getParent());
  
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          }
      }
  }
  ```

---

* 类加载机制的基本特征

  通常类加载机制有三个基本特征

  * 双亲委派模型。但不是所有类加载器都遵循这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供这些默认的参考实现。例如Java中的 JNDI、JDBC、文件系统、Cipher等很多方面，都是利用这种机制，这种情况就不会用双亲委派机制，而是利用所谓的上下文加载器。
  * 可见性，子类加载器可以访问父类加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器实现容器的逻辑。
  * 单一性。由于父加载器的类型对于子加载器时可见的，所以父加载器加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为相互并不可见。



## 2 类的加载器

* 类的加载器分类

  * JVM支持两种类型的类加载器，分别是<font color=red>**引导类加载器（Bootstrap ClassLoader）**</font>和<font color=red>**自定义类加载器（User-Defined ClassLoader）**</font>

  * 从概念上讲，自定义类加载器是指程序中由开发人员自定义的一类加载器，然而Java虚拟机规范却并没有这么定义，而是<font color=red>**将所有派生与抽象类ClassLoader的类加载器都划分为自定义类加载器**</font>。

  * 无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有三个，如下图：

    <img src="images/49.png" alt="img" style="zoom:80%;" />

    * 除了顶层的启动类加载器外，其余的类加载器都应该有自己的“父类”加载器。

    * 不同类加载器看似继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。类似于下面的方式：

      ```java
      class ClassLoader {
          ClassLoader parent;  // 父类加载器
          
          public ClassLoader(ClassLoader parent) {
              this.parent = parent;
          }
      }
      class ParentClassLoader extends ClassLoader{
          public ParentClassLoader(ClassLoader parent) {
              super(parent);
          }
      }
      
      class ChildClassLoader extends ClassLoader{
          public ChildClassLoader(ClassLoader parent) {  // parent = new ParentClassLoader();
              super(parent);
          }
      }
      ```

---

* ==启动类加载器（引导类加载器，Bootstrap ClassLoader）==

  * 这个类加载使用<font color=red>**C/C++语言实现的**</font>，嵌套在JVM内部
  * 它用来加载Java核心类库(JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容)，用于提供JVM自身需要的类
  * 并不继承自java.lang.ClassLoader，没有父加载器
  * 加载扩展类和应用程序加载器，并指定为他们的父类加载器
  * 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类

  <img src="images/50.png" alt="img" style="zoom:80%;" />

  <img src="images/51.png" alt="img" style="zoom:80%;" />

  使用-XX:+TraceClassLoading参数得到。

  * 启动类加载器使用C++编写的？Yes!
    * C/C++：指针函数&函数指针、C++支持多继承、更加高效
    * Java：由C++演变而来，(C++)--版，单继承

---

* ==扩展类加载器（Extension ClassLoader）==

  * <font color=red>**Java语言编写**</font>，由sun.misc.Launcher$ExtClassLoader实现。

  * <font color=red>**派生于ClassLoader类**</font>

  * 父类加载器为启动类加载器

  * 从java.ext.dirs系统属性所指定的目录加载类库，或从JDK安装目录的jre/lib/ext子目录（扩展目录）下加载类库。<font color=red>**如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载**</font>。

    ![img](images/52.png)

    <img src="images/53.png" alt="img" style="zoom:80%;" />

---

* ==应用程序类加载器（系统类加载器，AppClassLoader）==
  * java语言编写，由sun.misc.Launcher$AppClassLoader实现。
  * <font color=red>**派生于ClassLoader类**</font>
  * 父类加载器为启动类加载器
  * 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
  * <font color=red>**该类加载是程序中默认的类加载器**</font>，一般来说，Java应用的类都是由它来完成加载
  * 通过ClassLoader.getSystemClassLoader()方法可以获取到该类加载器

---

* ==用户自定义类加载器==
  * 在Java日常应用程序开发中，类的加载几乎是由上述3种加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。
  * 体现Java语言强大生命力和巨大魅力的关键因素之一便是：Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。
  * <font color=red>**通过类加载器可以实现非常绝妙的插件机制**</font>，这方面的实际应用举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无需重新打包发布应用程序就能实现。
  * 同时，<font color=red>**自定义加载器能够实现应用隔离**</font>，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。
  * 自定义类加载器通常需要继承于ClassLoader（但是注意自定义类加载器.getParent()是系统类加载器AppClassLoader）。



## 3 测试不同的类加载器

* 每个Class对象都会包含一个定义它的ClassLoader的一个引用

* 获取ClassLoader的途径：

  * 获得当前类的ClassLoader：

    ```java
    clazz.getClassLoader();
    ```

  * 获得当前线程上下文的ClassLoader：

    ```java
    Thread.currentThread().getContextClassLoader();
    ```

  * 获得系统的ClassLoader：

    ```java
    ClassLoader.getSystemClassLoader();
    ```

  **说明：**

  站在程序员的角度看，引导加载器与另外两种类加载器（系统类加载器 和 扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用C++语言编写的，而另外两类加载器则是使用Java语言编写的。由于引导类加载器压根儿就不是一个Java类，因此Java程序中只能打印出空值（null）。

* 数组类的Class对象，不是由类加载器去创建的。对于数组类的类加载器来说，是通过Class.getClassLoader()返回的，与数组当中元素类型的类加载器时一样的；如果数组当中的元素类型是基本数据类型，数组类是没有加载器的。

```java
public class ClassLoaderTest1 {
    public static void main(String[] args) {
        // 获取系统该类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);  // sun.misc.Launcher$AppClassLoader@18b4aac2
        // 获取扩展类加载器
        ClassLoader extClassLoader = systemClassLoader.getParent();
        System.out.println(extClassLoader);  // sun.misc.Launcher$ExtClassLoader@1540e19d
        // 试图获取引导类加载器：失败
        ClassLoader bootstrapClassLoader = extClassLoader.getParent();
        System.out.println(bootstrapClassLoader);  // null

        // ###########################
        try {
            ClassLoader classLoader = Class.forName("java.lang.String").getClassLoader();
            System.out.println(classLoader);
            // 自定义的类默认使用系统类加载器
            ClassLoader classLoader1 = Class.forName("com.atguigu.java.ClassLoaderTest1").getClassLoader();
            System.out.println(classLoader1);

            // 关于数组类型的加载:使用的类的加载器与数组元素的类的加载器相同
            String[] arrStr = new String[10];
            System.out.println(arrStr.getClass().getClassLoader());  // null:表示使用的是引导类加载器

            ClassLoaderTest1[] arr1 = new ClassLoaderTest1[10];
            System.out.println(arr1.getClass().getClassLoader());  // sun.misc.Launcher$AppClassLoader@18b4aac2

            int[] arr2 = new int[10];
            System.out.println(arr2.getClass().getClassLoader());  // null:不需要类的加载器


            System.out.println(Thread.currentThread().getContextClassLoader());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

